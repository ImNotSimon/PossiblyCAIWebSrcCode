import {
  Character,
  CharacterHistory,
  CharacterHistoryShunt,
  NotificationModeUpdate,
  NotificationRegisterRequest,
  RecentChatShunt,
} from '../types/app-api';
import {
  dedupedRecentChats,
  getHistoryLastInteractionTime,
  getLastInteractionTime,
  isNeoChat,
} from '../types/type-utils';
import { axios } from '../lib/axios';
import { getApiURL } from '../lib/axiosConstants';
import { convertMessageToTurn } from './chatManagerUtils';
import {
  Annotation,
  Chat,
  CreateAnnotationResponse,
  NeoChatHistoryResponseData,
  NeoRecentChatResponse,
  NeoRecentChatsResponse,
  TurnKey,
} from './chatServiceTypes';
import { legacyAPI } from './legacyAPI';
import { TurnCount } from '../types/roomTypes';
import { ErrorLogger } from '../DebugLog';

export const neoAPI = {
  fetchCombinedRecentChats: async (
    userCanUseNeo: boolean,
    dedupeCharacters?: boolean,
  ) => {
    const [legacyChats, neoChats] = await Promise.all([
      legacyAPI.fetchRecentCharacters(),
      userCanUseNeo ? neoAPI.fetchRecentChats() : undefined,
    ]);

    let combined: (Chat | Character)[] = [];
    if (legacyChats) {
      combined.push(...legacyChats);
    }
    if (neoChats) {
      combined.push(...neoChats);
    }

    combined.sort(
      (a, b) => getLastInteractionTime(b) - getLastInteractionTime(a),
    );

    return dedupeCharacters ? dedupedRecentChats(combined) : combined;
  },
  fetchMergedRecentChats: async (
    userCanUseNeo: boolean,
    dedupeCharacters?: boolean,
  ) => {
    const dedupedCombinedChats = await neoAPI.fetchCombinedRecentChats(
      userCanUseNeo,
      dedupeCharacters,
    );
    const mergedChats = dedupedCombinedChats.map<RecentChatShunt>(chat => {
      if (isNeoChat(chat)) {
        return {
          id: chat.chat_id,
          character_id: chat.character_id,
          name: chat.character_name ?? 'Unknown',
          avatar_file_name: chat.character_avatar_uri,
          date: chat.create_time,
          character_visibility: chat.character_visibility,
          isNeo: true,
          unread_count: chat.unread_count,
        };
      }

      return {
        id: chat.external_id,
        character_id: chat.external_id,
        name: chat.participant__name,
        avatar_file_name: chat.avatar_file_name,
        date: chat.max_last_interaction ?? new Date().toISOString(),
        character_visibility: chat.visibility as any,
        isNeo: false,
      };
    });

    return mergedChats;
  },
  fetchMergedHistories: async (
    character_id: string,
    userCanUseNeo: boolean,
  ) => {
    const dedupedCombinedHistories = await neoAPI.fetchCombinedHistories(
      character_id,
      userCanUseNeo,
    );
    const mergedChats = dedupedCombinedHistories.map<CharacterHistoryShunt>(
      chat => {
        if (isNeoChat(chat)) {
          return {
            ...chat,
            isNeo: true,
          };
        }

        const charMsg = chat.msgs.filter(m => !m.src__is_human)[0];
        const previewTurns = chat.msgs.map(m =>
          convertMessageToTurn(m, chat.external_id),
        );

        return {
          chat_id: chat.external_id,
          character_id: '',
          character_name: charMsg?.src__name ?? 'Unknown',
          character_avatar_uri: charMsg?.src_char.avatar_file_name ?? '',
          last_interaction: chat.last_interaction,
          isNeo: false,
          preview_turns: previewTurns,
        };
      },
    );

    return mergedChats;
  },
  fetchCombinedHistories: async (
    character_id: string,
    userCanUseNeo: boolean,
    numPreviewTurns: number = 2,
  ) => {
    const [legacyHistory, neoHistoryResponse] = await Promise.all([
      legacyAPI.fetchCharacterChatHistories(character_id),
      userCanUseNeo
        ? neoAPI.fetchChats(character_id, numPreviewTurns)
        : undefined,
    ]);

    const neoHistories = neoHistoryResponse?.data.chats;
    if (neoHistories) {
      for (const h of neoHistories) {
        if (h.preview_turns?.length) {
          const lastTurn = h.preview_turns[h.preview_turns.length - 1];
          h.last_interaction = lastTurn.create_time;
        }
      }
    }

    let combined: (Chat | CharacterHistory)[] = [];
    if (legacyHistory) {
      combined.push(...legacyHistory);
    }
    if (neoHistories) {
      combined.push(...neoHistories);
    }

    combined.sort(
      (a, b) =>
        getHistoryLastInteractionTime(b) - getHistoryLastInteractionTime(a),
    );

    return combined;
  },

  fetchRecentChat: async (external_id: string) => {
    const response = await axios()<NeoRecentChatsResponse>({
      baseURL: getApiURL(),
      method: 'get',
      url: `/chats/recent/${external_id}`,
    });
    if (response) {
      return response;
    } else {
      throw new Error('No response from server');
    }
  },
  fetchRecentChats: async () => {
    const response = await axios()<NeoRecentChatsResponse>({
      baseURL: getApiURL(),
      method: 'get',
      url: `chats/recent/`,
    });
    if (response) {
      return neoAPI.fetchRecentChatsUnreadCount(response.data.chats);
    } else {
      throw new Error('No response from server');
    }
  },
  fetchRecentChatsUnreadCount: async (chats: Chat[]) => {
    if (!chats?.length) {
      return chats;
    }
    try {
      // The api requires a timestamp field, but its unused and can be anything :/
      const timestamp = new Date().toISOString();
      const chat_markers = chats.map(chat => {
        return { chat_id: chat.chat_id, timestamp };
      });
      const unreadCounts = await axios()<{
        turn_counts: TurnCount[];
      }>({
        baseURL: getApiURL(),
        method: 'post',
        url: '/turns/count',
        data: { chat_markers },
      });
      unreadCounts.data.turn_counts.forEach(turnCount => {
        const chat = chats.find(chat => chat.chat_id === turnCount.chat_id);
        if (chat) {
          chat.unread_count = Number(turnCount.count ?? 0);
        }
      });
    } catch (error) {
      ErrorLogger.logError('Failed to fetch recent chats unread counts', {
        error,
      });
    }

    return chats;
  },
  fetchChat: async (chat_id: string, params?: any) => {
    const response = await axios()<NeoRecentChatResponse>({
      baseURL: getApiURL(),
      method: 'get',
      url: `chat/${chat_id}`,
      params,
    });
    if (response) {
      return response;
    }
  },
  fetchChats: async (
    character_id: string | undefined,
    num_preview_turns?: number,
  ) => {
    const response = await axios()<NeoRecentChatsResponse>({
      baseURL: getApiURL(),
      method: 'get',
      url: `chats/`,
      params: { character_ids: character_id, num_preview_turns },
    });
    if (response) {
      return response;
    }
  },
  fetchTurns: async (chatId: string, params?: any) => {
    const response = await axios()<NeoChatHistoryResponseData>({
      baseURL: getApiURL(),
      method: 'get',
      url: `turns/${chatId}/`,
      params,
    });
    if (response) {
      return response;
    } else {
      throw new Error('No turns response from server');
    }
  },
  resurrectChat: async (chatId: string) => {
    const response = await axios()<NeoChatHistoryResponseData>({
      baseURL: getApiURL(),
      method: 'get',
      url: `chat/${chatId}/resurrect`,
    });
    if (response) {
      return response;
    }
  },
  hideCharacterChat: async (characterId: string) => {
    // result will be true if either hide succeeds
    let result = false;
    try {
      await axios()<void>({
        baseURL: getApiURL(),
        method: 'put',
        url: `chats/recent/${characterId}/hide`,
      });
      result = true;
    } catch {
      // best effort, don't care if it fails
    }

    try {
      const response = await axios().post<{ status: string }>(
        '/chat/history/hide/',
        {
          character_external_id: characterId,
        },
      );

      result = result || response.data.status === 'OK';
    } catch {
      // best effort, don't care if it fails
    }

    return result;
  },
  healthCheck: async () => {
    const response = await axios()<any>({
      baseURL: getApiURL(),
      method: 'get',
      url: `health/`,
    });
    if (response) {
      console.log(response);
    }
  },
  ping: async () => {
    await axios()<any>({
      baseURL: getApiURL(),
      method: 'get',
      url: `ping/`,
      withCredentials: true,
    });
  },
  createAnnotation: async (
    turn_key: TurnKey,
    candidate_id: string,
    annotation: Partial<Annotation>,
  ) => {
    const response = await axios()<CreateAnnotationResponse>({
      baseURL: getApiURL(),
      method: 'post',
      url: `annotation/create`,
      data: { turn_key, candidate_id, annotation },
    });
    if (response) {
      return response;
    }
  },
  removeAnnotation: async (
    turn_key: TurnKey,
    candidate_id: string,
    annotation_id: string,
  ) => {
    const response = await axios()<NeoRecentChatsResponse>({
      baseURL: getApiURL(),
      method: 'post',
      url: `annotation/remove`,
      data: { turn_key, candidate_id, annotation_id },
    });
    if (response) {
      return response;
    }
  },
  notificationsRegister: async (data: NotificationRegisterRequest) => {
    return await axios()({
      baseURL: getApiURL(),
      method: 'put',
      url: `device_register/`,
      data,
    });
  },
  notificationModeUpate: async (mode: NotificationModeUpdate) => {
    return await axios()({
      baseURL: getApiURL(),
      method: 'put',
      url: `/notifications?mode=${mode.mode}`,
    });
  },
  deleteAccount: async (exportData: boolean = false) => {
    return await axios()({
      baseURL: getApiURL(),
      method: 'delete',
      url: `/account`,
      data: {
        export_data: exportData,
      },
    });
  }
};
