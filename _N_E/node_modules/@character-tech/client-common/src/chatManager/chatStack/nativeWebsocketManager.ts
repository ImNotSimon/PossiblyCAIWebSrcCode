import {
  getDebugMode,
  getModelServerURL,
  getOriginId,
  getWSAddress,
  getWebsocketHeartbeatMs,
} from '../../lib/axiosConstants';
import { __global } from '../../lib/globals';
import {
  ChatEventEnum,
  ChatEventWebsocketErrorPayload,
  WebsocketStatus,
} from './../chatManagerTypes';
import { extractChatInstanceUUID } from '../chatManagerUtils';
import {
  NeoSendSocketCommands,
  WebSocketCloseEvent,
  WebSocketErrorEvent,
  WebSocketMessageEvent,
} from '../chatServiceTypes';
import { BaseWebsocketManager } from './baseWebsocketManager';
import { AppChatSocket } from './websocketManager';
import { websocketRegistration } from './websocketRegistration';
import { ErrorLogger } from '../../DebugLog';

const MaxWebsocketRetryAttempts = 10;

// These became undefined when we imported a different library.
// These definitions are based on the typescript library definitions.
enum WebsocketConnectionStatus {
  CONNECTING = 0,
  OPEN = 1,
  CLOSING = 2,
  CLOSED = 3,
}

export class NativeWebsocketManager
  extends BaseWebsocketManager
  implements AppChatSocket
{
  socket: WebSocket | null = null;
  wsRetryAttemps = 0;
  heartbeatInterval = 0;
  inflightRequests: any[] = [];
  sendQueue: any[] = [];

  constructor(
    onChatEventCallback: (eventType: ChatEventEnum, payload?: any) => void,
  ) {
    super(onChatEventCallback);
    this.setupWebsocket();
  }

  isConnected() {
    return this.socket?.readyState === WebsocketConnectionStatus.OPEN;
  }

  isConnectedOrConnecting() {
    return (
      this.authState === 'authenticating' ||
      this.socket?.readyState === WebsocketConnectionStatus.OPEN ||
      this.socket?.readyState === WebsocketConnectionStatus.CONNECTING
    );
  }

  send(payload: Record<string, any>) {
    if (this.isConnected()) {
      this.sendInternal(payload);
    } else {
      this.sendQueue.push(payload);
      this.reconnectWebsocket();
    }
  }

  disconnectWebsocket() {
    // prevent retry attempts
    this.wsRetryAttemps = MaxWebsocketRetryAttempts;
    this.socket?.close();
  }

  reconnectWebsocket() {
    // Caller has requested a reconnect, clear our retries
    this.wsRetryAttemps = 0;
    // Don't bother reconnecting if we're already trying/done
    if (!this.isConnectedOrConnecting()) {
      this.setupWebsocket();
    }
  }

  subscribeToRoom(_chatId: string) {
    throw new Error(
      'Not implemented: Trying to use native websockets with rooms',
    );
  }

  unsubscribeFromRoom(_chatId: string) {
    throw new Error(
      'Not implemented: Trying to use native websockets with rooms',
    );
  }

  async setupWebsocket() {
    await this.authenticate();
    // we still want to try to connect even if auth failed
    // that will trigger a retry if auth doesn't work
    this.createWebsocket();
  }

  private createWebsocket() {
    clearInterval(this.heartbeatInterval);
    this.socket = new WebSocket(getWSAddress());

    this.socket.onopen = () => {
      console.log('Core Websocket Opened');
      this.wsRetryAttemps = 0;
      this.onChatEventCallback(ChatEventEnum.websocket_status, {
        status: WebsocketStatus.open,
      });

      // empty pending queue
      this.sendQueue.forEach(payload => {
        this.sendInternal(payload);
      });
      this.sendQueue = [];

      const heartbeatMs = getWebsocketHeartbeatMs();
      if (heartbeatMs > 0) {
        // @ts-ignore NEEDED to avoid breaking builds. Thinks setInterval returns NodeJS.Timer
        this.heartbeatInterval = setInterval(() => {
          this.sendInternal({
            command: NeoSendSocketCommands.ping,
          });
        }, heartbeatMs);
      }
    };

    this.socket.onerror = (ev: Event) => {
      const event = ev as WebSocketErrorEvent;
      ErrorLogger.logError('Native websocket error', { extra: { event } });
      this.checkAuthentication(event);
      this.onChatEventCallback(ChatEventEnum.websocket_status, {
        status: WebsocketStatus.error,
      });
      this.onChatEventCallback(ChatEventEnum.websocket_error, {
        comment: event.message,
        error_code: '',
      } as ChatEventWebsocketErrorPayload);
      this.raiseErrorCallbacksForPendingRequests();
    };

    this.socket.onclose = (event: WebSocketCloseEvent) => {
      this.checkAuthentication(event);
      console.log('WS Closed', event);
      clearInterval(this.heartbeatInterval);
      clearTimeout(this.ttlTimer);
      this.raiseErrorCallbacksForPendingRequests();
      if (this.wsRetryAttemps < MaxWebsocketRetryAttempts) {
        this.onChatEventCallback(ChatEventEnum.websocket_status, {
          status: WebsocketStatus.reconnecting,
        });
        console.log('Retrying, retry attempt:', this.wsRetryAttemps);
        this.setupWebsocket();
        this.wsRetryAttemps++;
      } else {
        this.onChatEventCallback(ChatEventEnum.websocket_status, {
          status: WebsocketStatus.closed,
        });
      }
    };

    this.socket.onmessage = (event: WebSocketMessageEvent) => {
      this.restartTTLTimer();
      const data = JSON.parse(event.data);
      // console.log("WS Message Recieved", data.command, data);
      if (data.request_id) {
        this.removeInflightRequest(data.request_id);
        const subscriberId = extractChatInstanceUUID(data.request_id);
        websocketRegistration.publish(data, subscriberId);
      } else {
        // console.log("no request_id to receive message");
      }
    };
  }

  private sendInternal(payload: Record<string, any>) {
    try {
      this.restartTTLTimer();
      if (this.socket) {
        console.log('Sending socket message', { command: payload?.command });
        this.addInflightRequest(payload);
        const debugMode = getDebugMode();
        if (debugMode && payload.payload) {
          payload.payload['debug_info'] = debugMode;
          const overrideModelServerURL = getModelServerURL();
          if (overrideModelServerURL) {
            payload.payload['model_server_url'] = overrideModelServerURL;
          }
        }

        const debugWSPayload = __global.getDebugWSPayload();
        if (!!debugWSPayload && payload.payload) {
          payload.payload = { ...payload.payload, ...debugWSPayload };
        }

        this.socket.send(
          JSON.stringify({ ...payload, origin_id: getOriginId() }),
        );
      } else {
        ErrorLogger.logError('no native websocket while sending message');
      }
    } catch (error) {
      ErrorLogger.logError('error sending message to native websocket', {
        error,
      });
    }
  }

  private raiseErrorCallbacksForPendingRequests() {
    this.inflightRequests.forEach(payload => {
      const subscriberId = extractChatInstanceUUID(payload.request_id);
      websocketRegistration.raiseError(subscriberId);
    });
    this.inflightRequests = [];

    this.sendQueue.forEach(payload => {
      const subscriberId = extractChatInstanceUUID(payload.request_id);
      websocketRegistration.raiseError(subscriberId);
    });
    this.sendQueue = [];
  }

  private addInflightRequest(payload: Record<string, any>) {
    if (payload.request_id) {
      // make sure we have a request id so we know when to remove from inflight
      this.inflightRequests.push(payload);
    }
  }

  private removeInflightRequest(requestId: string) {
    this.inflightRequests = this.inflightRequests.filter(
      item => item.request_id !== requestId,
    );
  }
}
