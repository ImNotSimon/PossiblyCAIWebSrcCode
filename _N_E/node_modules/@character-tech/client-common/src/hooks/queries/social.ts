import { useMemo } from 'react';
import { axios } from '../../lib/axios';
import {
  Character,
  Followers,
  Following,
  PublicUser,
} from '../../types/app-api';
import { authQueries, characterQueries } from './baseQueries';
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useQueryClient,
} from './setup';

export const socialKeys = {
  user: ['user'] as const,
  publicUser: (username: string) => [...socialKeys.user, 'public', username],
  publicFollowers: (username: string) => [
    ...socialKeys.user,
    'public',
    'followers',
    username,
  ],
  publicFollowing: (username: string) => [
    ...socialKeys.user,
    'public',
    'following',
    username,
  ],
  followers: () => [...socialKeys.user, 'followers'],
  following: () => [...socialKeys.user, 'following'],
  votedFor: (characterId: string) => [
    ...socialKeys.user,
    'voted-for',
    characterId,
  ],
  votes: (characterId: string) => ['votes', characterId],
  upvotesByCharacter: (listName: string) => ['upvotes-by-character', listName],
  upvotedCharacters: () => [...socialKeys.user, 'upvoted-characters'] as const,
};

export const useGetPublicUser = (username: string, isAnonymous: boolean) => {
  const query = useQuery({
    queryKey: socialKeys.publicUser(username),
    queryFn: async () => {
      if (isAnonymous) {
        const response = await axios().post<{ public_user: PublicUser }>(
          '/chat/anon/user/public/',
          {
            username,
          },
        );
        return response.data.public_user;
      } else {
        const response = await axios().post<{ public_user: PublicUser }>(
          '/chat/user/public/',
          {
            username,
          },
        );
        return response.data.public_user;
      }
    },
    staleTime: Infinity,
  });

  return {
    user: query.data,
    ...query,
  };
};

export const useGetFollowing = () => {
  const query = useQuery({
    queryKey: socialKeys.following(),
    queryFn: async () => {
      const response = await axios().get<{ following: Following }>(
        '/chat/user/following/',
      );
      return response.data.following;
    },
    staleTime: Infinity,
  });

  return {
    following: query.data,
    ...query,
  };
};

export const useGetFollowers = () => {
  const query = useQuery({
    queryKey: socialKeys.followers(),
    queryFn: async () => {
      const response = await axios().get<{ followers: Followers }>(
        '/chat/user/followers/',
      );
      return response.data.followers;
    },
    staleTime: Infinity,
  });

  return {
    followers: query.data,
    ...query,
  };
};

interface SocialAction {
  username: string;
  requesterUsername?: string;
}

export const useFollowUser = () => {
  const queryClient = useQueryClient();
  return useMutation(
    async ({ username, requesterUsername }: SocialAction) => {
      const response = await axios().post('/chat/user/follow/', { username });
      return { ...response.data, username, requesterUsername };
    },
    {
      onSuccess: response => {
        const { username, requesterUsername } = response;
        queryClient.invalidateQueries(socialKeys.following());
        if (requesterUsername) {
          queryClient.invalidateQueries(
            socialKeys.publicFollowing(requesterUsername),
          );
          // to update the following counts
          queryClient.invalidateQueries(
            socialKeys.publicUser(requesterUsername),
          );
        }
        queryClient.invalidateQueries(socialKeys.publicUser(username));
        queryClient.invalidateQueries(socialKeys.publicFollowers(username));
      },
    },
  );
};

export const useUnfollowUser = () => {
  const queryClient = useQueryClient();
  return useMutation(
    async ({ username, requesterUsername }: SocialAction) => {
      const response = await axios().post('/chat/user/unfollow/', { username });
      return { ...response.data, username, requesterUsername };
    },
    {
      onSuccess: response => {
        const { username, requesterUsername } = response;
        queryClient.invalidateQueries(socialKeys.following());
        if (requesterUsername) {
          queryClient.invalidateQueries(
            socialKeys.publicFollowing(requesterUsername),
          );
          // to update the following counts
          queryClient.invalidateQueries(
            socialKeys.publicUser(requesterUsername),
          );
        }
        queryClient.invalidateQueries(socialKeys.publicUser(username));
        queryClient.invalidateQueries(socialKeys.publicFollowers(username));
      },
    },
  );
};

export const useBlockUser = (unblock: boolean) => {
  const queryClient = useQueryClient();
  return useMutation(
    async ({ username }: SocialAction) => {
      const response = await axios().post('/chat/user/block/', {
        username,
        unblock,
      });
      return { ...response.data, username };
    },
    {
      onSuccess: () => {
        queryClient.invalidateQueries([authQueries.charUser.keys()]);
      },
    },
  );
};

export interface SocialUserInfo {
  username: string;
  account__avatar_file_name: string;
  account__bio?: string;
}

export type SocialInfoResponse = {
  users: SocialUserInfo[];
  has_next_page: boolean;
  meta: {
    next_token?: string;
  };
};

export const useGetPublicFollowers = (username: string) => {
  const query = useInfiniteQuery(
    socialKeys.publicFollowers(username),
    async ({ pageParam }) => {
      if (!username) {
        return { users: [], has_next_page: false, meta: {} };
      }
      const response = await axios().post<SocialInfoResponse>(
        '/chat/user/public/followers/',
        {
          username,
          // we must explicitly fallback to 1 here because useInfiniteQuery will set pageParam to null
          pageParam: pageParam ?? 1,
        },
      );
      return response.data;
    },
    {
      getNextPageParam: (lastPage, allPages) => {
        return lastPage.has_next_page ? allPages.length + 1 : undefined;
      },
      staleTime: Infinity,
    },
  );

  const users = useMemo(() => {
    return query.data?.pages?.flatMap(page => page.users) ?? [];
  }, [query.data?.pages]);

  return { ...query, users };
};

export const useGetPublicFollowing = (username: string) => {
  const query = useInfiniteQuery(
    socialKeys.publicFollowing(username),
    async ({ pageParam }) => {
      if (!username) {
        return { users: [], has_next_page: false, meta: {} };
      }
      const response = await axios().post<SocialInfoResponse>(
        '/chat/user/public/following/',
        {
          username,
          // we must explicitly fallback to 1 here because useInfiniteQuery will set pageParam to null
          pageParam: pageParam ?? 1,
        },
      );
      return response.data;
    },
    {
      getNextPageParam: (lastPage, allPages) => {
        return lastPage.has_next_page ? allPages.length + 1 : undefined;
      },
      staleTime: Infinity,
    },
  );

  const users = useMemo(() => {
    return query.data?.pages?.flatMap(page => page.users) ?? [];
  }, [query.data?.pages]);

  return { ...query, users };
};

export const useGetVotedFor = (characterId: string) => {
  const query = useQuery({
    queryKey: socialKeys.votedFor(characterId),
    queryFn: async () => {
      const response = await axios().get<{
        status: string;
        voted: boolean;
        vote: boolean;
      }>(`/chat/character/${characterId}/voted/`);
      return response.data;
    },
    staleTime: Infinity,
  });

  return {
    voted: query.data?.voted,
    vote: query.data?.vote,
    ...query,
  };
};

export const useGetCharacterVotes = (characterId: string) => {
  const query = useQuery({
    queryKey: socialKeys.votes(characterId),
    queryFn: async () => {
      const response = await axios().get<{
        status: string;
        upvotes: number;
      }>(`/chat/character/${characterId}/votes/`);
      return response.data;
    },
    staleTime: Infinity,
  });

  return {
    upvotes: query.data?.upvotes,
    ...query,
  };
};

export const useGetCharactersVotes = (
  characterIds: string[],
  listName: string,
) => {
  const query = useQuery({
    queryKey: socialKeys.upvotesByCharacter(listName),
    queryFn: async () => {
      const response = await axios().post<{
        status: string;
        upvotes_per_character: { [external_id: string]: number };
      }>('/chat/characters/votes/', {
        character_ids: characterIds,
      });
      return response.data;
    },
    enabled: characterIds.length > 0,
    staleTime: Infinity,
  });

  return {
    upvotes_per_character: query.data?.upvotes_per_character,
    ...query,
  };
};

interface VoteAction {
  characterId: string;
  vote: boolean | null;
}

export const useUpdateCharacterVote = () => {
  const queryClient = useQueryClient();
  return useMutation(
    async ({ characterId, vote }: VoteAction) => {
      const response = await axios().post('/chat/character/vote/', {
        external_id: characterId,
        vote,
      });
      return { ...response.data, characterId };
    },
    {
      onSuccess: response => {
        queryClient.invalidateQueries(socialKeys.votes(response.characterId));
        queryClient.invalidateQueries(
          socialKeys.votedFor(response.characterId),
        );
        queryClient.invalidateQueries(socialKeys.upvotedCharacters());
        queryClient.invalidateQueries(
          characterQueries.info.keys(response.characterId),
        );
      },
    },
  );
};

export const useGetUpvotedCharacters = (disabled?: boolean) => {
  const query = useQuery({
    queryKey: socialKeys.upvotedCharacters(),
    queryFn: async () => {
      const response = await axios().get<{ characters: Character[] }>(
        '/chat/user/characters/upvoted/',
      );
      return response.data.characters;
    },
    staleTime: Infinity,
    enabled: !disabled,
  });

  return {
    characters: query.data,
    ...query,
  };
};
