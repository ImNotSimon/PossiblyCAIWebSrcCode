import { useMemo } from 'react';
import { axios } from '../../lib/axios';
import { hiddenCharacters } from '../../state/signals';
import {
  CompleteSignupParams,
  EditUserFormData,
  UserSettings,
} from '../../types/app-api';
import { UserDataActionStatus } from '../../types/types';
import { authQueries, userQueries } from './baseQueries';
import { personaKeys } from './persona';
import { useMutation, useQuery, useQueryClient } from './setup';

export const useUserSettings = () => {
  const query = useQuery({
    queryKey: userQueries.settings.keys(),
    queryFn: () => userQueries.settings.queryFn(),
    staleTime: Infinity,
  });

  return {
    ...query,
    settings: query.data?.data,
  };
};

export const useUserCharacters = (scope: 'user' | '' = 'user') => {
  const query = useQuery({
    queryKey: userQueries.characters.keys(scope),
    queryFn: () => userQueries.characters.queryFn(scope),
    staleTime: Infinity,
  });

  const characterState = useMemo(() => {
    const userCharacters = query.data?.data?.characters;
    const publicCharacters =
      userCharacters?.filter(c => c.visibility === 'PUBLIC') ?? [];
    const privateCharacters =
      userCharacters?.filter(c => c.visibility === 'PRIVATE') ?? [];
    const unlistedCharacters =
      userCharacters?.filter(c => c.visibility === 'UNLISTED') ?? [];

    const interactionCount = publicCharacters.reduce((sum, character) => {
      return sum + character.participant__num_interactions;
    }, 0);

    return {
      userCharacters,
      publicCharacters,
      privateCharacters,
      unlistedCharacters,
      interactionCount,
    };
  }, [query.data?.data?.characters]);

  return {
    ...query,
    ...characterState,
  };
};

export const useUpdateUserSettings = () => {
  const queryClient = useQueryClient();
  return useMutation(
    async (updatedSettings: UserSettings) => {
      const response = await axios().post(
        '/chat/user/update_settings/',
        updatedSettings,
      );
      return response;
    },
    {
      onSuccess: () => {
        // k-TODO: use response to update the value of the query to avoid additional fetch
        queryClient.invalidateQueries(userQueries.settings.keys());

        // we want to invalidate the personas in case the persona-specific settings changed
        queryClient.invalidateQueries(personaKeys.personas());
      },
    },
  );
};

export const useUpdateUserProfile = () => {
  const queryClient = useQueryClient();
  return useMutation(
    async (data: EditUserFormData) => {
      const response = await axios().post('/chat/user/update/', {
        username: data.username?.trim(),
        name: data.name?.trim(),
        avatar_type: data.avatar_type,
        avatar_rel_path: data.avatar_rel_path,
        bio: data.bio?.trim(),
      });
      return response;
    },
    {
      onSuccess: () => {
        queryClient.invalidateQueries([authQueries.charUser.keys()]);
      },
    },
  );
};

export const useDeactivateUser = () => {
  return useMutation(async () => axios().post('/chat/user/deactivate/', {}));
};

export const useCreateDataAction = () => {
  const mutation = useMutation(async function (data: {
    status: UserDataActionStatus;
    actionParams: {
      dry_run: boolean;
      need_exported_data: boolean;
      need_deleted_account: boolean;
    };
  }): Promise<void> {
    await axios().post('chat/user/data/action/', {
      status: data.status,
      dry_run: data.actionParams.dry_run,
      need_exported_data: data.actionParams.need_exported_data,
      need_deleted_account: data.actionParams.need_deleted_account,
    });
  });
  return mutation;
};

export const useUpdateUserAcknowledgement = () => {
  return useMutation(async (acknowledgement: boolean) => {
    return axios().post('/chat/user/acknowledge/', {
      acknowledgement,
    });
  });
};

export const useGetCharToken = (id_token?: string, access_token?: string) => {
  const query = useQuery({
    queryKey: ['char-token'],
    queryFn: () =>
      axios().post<{ key: string }>('/dj-rest-auth/auth0/', {
        access_token: access_token,
        id_token: id_token,
      }),
    staleTime: Infinity,
    enabled: !!access_token,
  });

  return {
    ...query,
    charToken: query.data?.data.key,
  };
};

export const useGetCharUser = (hasToken: boolean) => {
  const query = useQuery({
    queryKey: authQueries.charUser.keys(),
    queryFn: () => authQueries.charUser.queryFn(),
    staleTime: Infinity,
    enabled: hasToken,
  });

  if (query.isFetched && query.data?.data?.user?.hidden_characters) {
    hiddenCharacters.value = query.data.data.user.hidden_characters;
  }

  return {
    user: query.data?.data.user,
    ...query,
    isLoading: query.isLoading && hasToken,
  };
};

export const useCompleteSignup = () => {
  const mutation = useMutation(
    async ({
      username,
      date_of_birth,
      userInEEA,
      userInUK,
      date_of_birth_collected,
      acknowledgement,
      avatar_type = '',
      avatar_file_name = '',
    }: CompleteSignupParams) => {
      return (
        await axios().post('/chat/user/signup/', {
          username,
          date_of_birth,
          userInEEA,
          userInUK,
          date_of_birth_collected,
          acknowledgement,
          name: username,
          avatar_type,
          avatar_file_name,
        })
      ).data as { status: string; needs_exit_signup: boolean };
    },
  );
  return mutation;
};
