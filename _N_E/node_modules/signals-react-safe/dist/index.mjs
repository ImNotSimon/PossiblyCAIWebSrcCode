// src/index.ts
import {
  Signal as Signal2,
  signal,
  computed as computed2,
  effect as effect2,
  batch,
  untracked
} from "@preact/signals-core";

// src/hooks.ts
import { Signal, computed, effect } from "@preact/signals-core";
import { useEffect, useMemo, useRef, useState } from "react";
function useSignalValue(signal2) {
  const [state, setState] = useState(signal2.value);
  useEffect(() => {
    return effect(() => setState(signal2.value));
  }, [signal2]);
  return state;
}
function useSignalAndValue(initialValue) {
  const signal2 = useSignal(initialValue);
  const value = useSignalValue(signal2);
  return [signal2, value];
}
function useComputedValue(compute) {
  const signal2 = useComputed(compute);
  const value = useSignalValue(signal2);
  return value;
}
function useSignal(initialValue) {
  return useMemo(() => new Signal(initialValue), []);
}
function useComputed(compute) {
  const $compute = useRef(compute);
  $compute.current = compute;
  return useMemo(() => computed(() => $compute.current()), []);
}
function useSignalEffect(cb) {
  const callback = useRef(cb);
  callback.current = cb;
  useEffect(() => {
    return effect(() => callback.current());
  }, []);
}

// src/index.ts
var ReactElemType = Symbol.for("react.element");
function SignalValue({ data }) {
  return useSignalValue(data);
}
Object.defineProperties(Signal2.prototype, {
  $$typeof: { configurable: true, value: ReactElemType },
  type: { configurable: true, value: SignalValue },
  props: {
    configurable: true,
    get() {
      return { data: this };
    }
  },
  ref: { configurable: true, value: null }
});
export {
  Signal2 as Signal,
  batch,
  computed2 as computed,
  effect2 as effect,
  signal,
  untracked,
  useComputed,
  useComputedValue,
  useSignal,
  useSignalAndValue,
  useSignalEffect,
  useSignalValue
};
//# sourceMappingURL=index.mjs.map