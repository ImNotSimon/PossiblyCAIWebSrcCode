import {
  Candidate,
  Chat,
  NeoChatState,
  NeoChatType,
  NeoChatVisibility,
  Turn,
} from './chatServiceTypes';
import { ChatHistoryResponse, Message } from '../types/app-api';
import { ViewChatMessage } from '../types/types';

const asyncIntervals: boolean[] = [];
/************************************ /
 * Suite of util functions to enable asynchronous interval functions
 */

export const runAsyncInterval = async (
  cb: () => void,
  interval: number,
  intervalIndex: number,
) => {
  await cb();
  if (asyncIntervals[intervalIndex]) {
    setTimeout(() => runAsyncInterval(cb, interval, intervalIndex), interval);
  }
};

export const setAsyncInterval = (cb: () => void, interval: number) => {
  if (cb && typeof cb === 'function') {
    const intervalIndex = asyncIntervals.length;
    asyncIntervals.push(true);
    runAsyncInterval(cb, interval, intervalIndex);
    return intervalIndex;
  } else {
    throw new Error('Callback must be a function');
  }
};

export const clearAsyncInterval = (intervalIndex: number) => {
  if (asyncIntervals[intervalIndex]) {
    asyncIntervals[intervalIndex] = false;
  }
};

/*
 Suite of utility functions to enable translation between legacy messages and neo turns
*/

export const convertMessageToTurn = (
  message: Message,
  chatHistoryId?: string,
): Turn => {
  return {
    author: {
      author_id:
        message.src_char.participant?.user?.id.toString() ?? 'undefined',
      is_human: message.src__is_human,
      name: message.src__name,
      avatar_url: message.src__character__avatar_file_name,
    },
    candidates: [convertMessageToTurnCandidate(message)],
    create_time: 'none',
    last_update_time: 'none',
    primary_candidate_id: message.uuid,
    state: 'STATE_OK',
    turn_key: {
      chat_id: chatHistoryId ?? 'none',
      turn_id: message.uuid,
    },
  };
};

export const convertMessageToTurnCandidate = (message: Message): Candidate => {
  return {
    candidate_id: message.uuid,
    create_time: 'none',
    raw_content: message.text,
    force_signin: message.force_signin,
    is_final: !message.inProgress,
    error: message.error,
    tti_image_rel_path: message.image_rel_path,
    fresh: message.fresh,
  };
};

export const processRawMessageToTurns = (
  messages: Message[],
  chatHistoryId?: string,
): Turn[] => {
  const result: Turn[] = [];
  /*
   roll alternates into nearest root message of same owner
  */
  let character = null;
  let creator = null;
  if (messages && messages.length > 0) {
    let i = messages.length - 1;
    let scanning = false;
    let candidateBatch = [];
    while (i >= 0) {
      const currentMessage = messages[i];
      // filter out empty human messages from display
      if (currentMessage) {
        if (!creator && currentMessage.src_char) {
          creator = currentMessage.responsible_user__username;
        }
        if (!character && currentMessage.src_char) {
          character = currentMessage.src__name;
        }
        if (currentMessage.src__is_human && currentMessage.text === '') {
        } else {
          // if an alternative
          if (currentMessage.is_alternative) {
            // if we arent already scanning
            if (!scanning) {
              scanning = true;
            }

            // add it to the batch
            // note: may need to reverse this list
            candidateBatch.push(currentMessage);
          } else if (scanning) {
            // if we are scanning, stop scanning and add the batch
            const turn = convertMessageToTurn(currentMessage, chatHistoryId);
            turn.candidates.push(
              ...candidateBatch
                .map(c => convertMessageToTurnCandidate(c))
                .reverse(),
            );
            result.push(turn);
            scanning = false;
            candidateBatch = [];
          } else {
            result.push(convertMessageToTurn(currentMessage, chatHistoryId));
          }
        }
      }

      i--;
    }
  }

  return result;
};

export const processViewChatMessages = (
  messages: ViewChatMessage[],
): ViewChatMessage[] => {
  let lastUserMessageFound = false;
  let lastAiMessageFound = false;
  const newProcessedMessages: ViewChatMessage[] = messages.map((msg, index) => {
    const isGreetingMessage = messages.length - index <= 2;
    const isLastUserMessage = !lastUserMessageFound && msg.author.is_human;
    const isLastAiMessage = !lastAiMessageFound && !msg.author.is_human;
    lastUserMessageFound = lastUserMessageFound || isLastUserMessage;
    lastAiMessageFound = lastAiMessageFound || isLastAiMessage;

    return {
      ...msg,
      candidates: msg.candidates,
      isGreetingMessage,
      isLastUserMessage,
      isLastAiMessage,
    };
  });

  return newProcessedMessages;
};

export const convertChatHistoryToChat = (
  chatHistory: ChatHistoryResponse,
): Chat => {
  return {
    character_id:
      chatHistory?.participants?.find(p => !p.is_human)?.user?.id.toString() ??
      '',
    chat_id: chatHistory.external_id,
    create_time: chatHistory.created,
    creator_id:
      chatHistory?.participants?.find(p => p.is_human)?.user?.id.toString() ??
      '',
    state: NeoChatState.active,
    type: NeoChatType.direct,
    visibility: NeoChatVisibility.public,
    character_visibility: 'UNLISTED',
  };
};

export const extractChatInstanceUUID = (uuid?: string): string => {
  if (uuid) {
    return uuid?.slice(24);
  } else {
    // TODO: some kinda gnarly error handling there
    throw new Error('UUID is undefined');
  }
};
export const extractRequestUUID = (uuid: string) => uuid.slice(0, 24);

export interface ClientViewMessage {
  uuid: string;
  author: {
    author_id: string;
    is_human: string;
    name: string;
    avatar_url: string; // new
  };
  candidates: ClientCandidate[];
}

export interface ClientCandidate {
  uuid: string;
  text: string;
  image_url: string;
}
