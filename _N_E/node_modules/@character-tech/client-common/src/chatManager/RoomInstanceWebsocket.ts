import { v4 as uuidv4 } from 'uuid';
import { Participant } from '../types/app-api';
import { ChatInstanceWebSocket } from './ChatInstanceWebsocket';
import {
  ChatEventEnum,
  ChatInstanceStatusEnum,
  ChatServiceType,
  ChatUpdateCallback,
  PublishCommand,
  PublishStateUpdate,
  SmartReplyType,
  TYPING_MSG,
} from './chatManagerTypes';
import { ChatTypesEnum, NeoSendSocketCommands } from './chatServiceTypes';
import { centrifugeChatSocket } from './chatStack/websocketManager';
import { websocketRegistration } from './chatStack/websocketRegistration';
import { neoAPI } from './neoAPI';
import { TypingIndicatorTimeoutMS } from './chatConstants';
import { ErrorLogger } from '../DebugLog';

export class RoomInstanceWebSocket extends ChatInstanceWebSocket {
  constructor(
    _serviceType: ChatServiceType,
    _external_id: string,
    _user: Participant,
    _onChatEventCallback: (eventType: ChatEventEnum, payload?: any) => void,
    _history_external_id?: string,
    _new_history?: boolean,
  ) {
    super(
      _serviceType,
      _external_id,
      _user,
      _onChatEventCallback,
      _history_external_id,
      _new_history,
    );
    this.setupTypingIndicatorInterval();
  }

  typingInterval: number = 0;
  setupTypingIndicatorInterval() {
    // @ts-ignore NEEDED to avoid breaking builds. Thinks setInterval returns NodeJS.Timer
    this.typingInterval = setInterval(() => {
      let dirtyList = false;
      for (let i = this.typingIndicatorMessaages.length - 1; i >= 0; i--) {
        const turn = this.typingIndicatorMessaages[i];
        if (turn.primary_candidate_id === TYPING_MSG) {
          const now = new Date().getTime();
          const diff = now - new Date(turn.last_update_time).getTime();
          if (diff > TypingIndicatorTimeoutMS) {
            this.removeTypingTurn(turn);
            dirtyList = true;
          }
        }
      }

      if (dirtyList) {
        this.publishChatMessages();
      }
    }, 3000);
  }

  isInitialized(): boolean {
    // Rooms aren't required to fetch chat history before they are initialized
    return true;
  }

  setupWebsocket() {
    websocketRegistration.subscribe(
      this.instanceID,
      this.onMessageReceived,
      this.onMessageError,
      () => {
        console.log('Room websocket connected, fetching messages', {
          instanceID: this.instanceID,
        });
        this.fetchMessageHistory();
      },
    );
    centrifugeChatSocket.subscribeToRoom(this.external_id, this.instanceID);
  }

  async fetchInitialData() {
    if (this.getStatus() === ChatInstanceStatusEnum.none) {
      // check ws state
      this.setStatus(ChatInstanceStatusEnum.fetchingHistory);
      this.fetchMessageHistory();
    }
  }

  async fetchMessageHistory() {
    console.log(`Room fetchMessageHistory ${this.instanceID}`);

    if (this.getStatus() === ChatInstanceStatusEnum.fetchMessages) {
      console.log("Already fetching messages for room, can't fetch again");
      return;
    }

    this.setStatus(ChatInstanceStatusEnum.fetchMessages);
    let params: any = {};
    let fetchMore = false;
    // add the next token for pagination if we got one
    if (this.nextToken) {
      params.next_token = this.nextToken;
      fetchMore = true;
    }

    try {
      const response = await neoAPI.fetchTurns(this.external_id, params);

      this.nextToken = response.data?.meta?.next_token;
      this.has_more = !!this.nextToken;

      const newTurns = response.data?.turns ?? [];
      // sort the candidates by create time
      newTurns.forEach(t => {
        t.candidates.sort((a, b) =>
          new Date(a.create_time) > new Date(b.create_time) ? 1 : -1,
        );
      });
      if (fetchMore) {
        this.turns = [...this.turns, ...newTurns];
      } else {
        // if we arent fetching more we want to make sure this message history is the only one
        this.turns = [...newTurns];
      }

      this.publishChatMessages();

      this.setStatus(ChatInstanceStatusEnum.none);
    } catch (error) {
      ErrorLogger.logError('Failed to get room message history', { error });
      this.onChatEventCallback(ChatEventEnum.unrecoverable_error, {
        comment: 'failed to get room',
        external_id: this.external_id,
        event_time: new Date().getTime(),
      });
      // set the component to dead
      this.setStatus(ChatInstanceStatusEnum.dead);
    }
  }

  async deleteMessages(uuids: string[], _callback: (success: boolean) => void) {
    if (uuids.length === 0) {
      return;
    }
    if (uuids.length > 1) {
      console.error('Rooms can only delete one message at a time');
    }
    const sendPayload = {
      command: NeoSendSocketCommands.remove_turn,
      request_id: this.buildRequestId(),
      payload: {
        turn_key: { chat_id: this.external_id, turn_id: uuids[0] },
      },
    };
    this.deleteCallback = _callback;
    this.sendSocketMessage(sendPayload);
  }

  sendChatMessage(publishCmd: PublishCommand) {
    switch (publishCmd.type) {
      case 'create':
        this.sendCreateCommand({
          messageText: publishCmd.message,
          context_reset: publishCmd.context_reset,
          smart_reply: publishCmd.smart_reply,
        });
        break;
      case 'generate':
        this.sendGenerateCommand(
          publishCmd.characterId,
          publishCmd.characterName,
        );
        break;
      case 'generate_room_candidate':
        this.sendGenerateRoomCandidateCommand(
          publishCmd.turnId,
          publishCmd.characterId,
        );
        break;
      case 'smart_turn':
        this.sendSmartGenerateTurn(publishCmd.smart_reply);
        break;
      case 'state_update':
        this.sendStateUpdateCommand(publishCmd);
        break;
      case 'edit_turn_candidate':
        this.editMessage(
          publishCmd.turnKey,
          publishCmd.candidateId,
          publishCmd.newRawContent,
        );
        break;
      default:
        console.log(
          `RoomInstanceWebSocket: ignoring ${publishCmd.type} send command`,
        );
    }
  }

  subscribe(callback: ChatUpdateCallback): () => void {
    const unsubscribe = super.subscribe(callback);
    if (this.subscriberCallbacks.length === 1) {
      // Ensure websocket is setup if we're gaining our first subscriber
      this.setupWebsocket();
    }
    return () => {
      unsubscribe();
      if (this.subscriberCallbacks.length === 0) {
        this.cleanup();
      }
    };
  }

  cleanup(): void {
    clearInterval(this.typingInterval);
    websocketRegistration.unsubscribe(this.instanceID);
    centrifugeChatSocket.unsubscribeFromRoom(this.external_id);
  }

  private sendCreateCommand(cmd: {
    messageText?: string;
    context_reset?: boolean;
    smart_reply?: SmartReplyType;
  }) {
    const newTurnId = uuidv4();
    const sendPayload = {
      command: cmd.smart_reply
        ? NeoSendSocketCommands.create_and_generate_turn
        : NeoSendSocketCommands.create_turn,
      request_id: this.buildRequestId(),
      payload: {
        smart_reply: cmd.smart_reply,
        chat_type: ChatTypesEnum.TYPE_MU_ROOM,
        num_candidates: 1,
        user_name: this.user.name,
        turn: {
          context_reset: cmd.context_reset,
          turn_key: {
            turn_id: newTurnId,
            chat_id: this.external_id,
          },
          author: {
            author_id: this.user.user?.id.toString(),
            is_human: true,
            name: this.user.name,
          },
          candidates: [
            {
              candidate_id: newTurnId,
              raw_content: cmd.messageText,
            },
          ],
          primary_candidate_id: newTurnId,
        },
      },
    };

    // add user dummy message
    if (cmd.messageText) {
      this.addDummyMessage(cmd.messageText, sendPayload.request_id);
    }

    // update mesages
    this.publishChatMessages();

    centrifugeChatSocket.send(sendPayload);
  }

  private sendGenerateCommand(characterId: string, _characterName: string) {
    const sendPayload = {
      command: NeoSendSocketCommands.generate_turn,
      request_id: this.buildRequestId(),
      payload: {
        chat_type: ChatTypesEnum.TYPE_MU_ROOM,
        character_id: characterId,
        chat_id: this.external_id,
      },
    };

    // add loading message

    // update mesages
    this.publishChatMessages();

    centrifugeChatSocket.send(sendPayload);
  }

  // generates a new candidate within a room
  private sendGenerateRoomCandidateCommand(
    turnId: string,
    characterId: string,
  ) {
    const sendPayload = {
      command: NeoSendSocketCommands.generate_turn_candidate,
      request_id: this.buildRequestId(),
      payload: {
        chat_type: ChatTypesEnum.TYPE_MU_ROOM,
        character_id: characterId,
        user_name: this.user.name,
        turn_key: {
          turn_id: turnId,
          chat_id: this.external_id,
        },
      },
    };
    const updatedTurnIndex = this.turns.findIndex(
      t => t.turn_key.turn_id === turnId,
    );

    if (updatedTurnIndex > -1) {
      // this turn is now back inflight
      this.turns[updatedTurnIndex].state = 'STATE_INFLIGHT';
      // update mesages
      this.publishChatMessages();
    }

    centrifugeChatSocket.send(sendPayload);
  }

  private sendSmartGenerateTurn(replyType: 'CHARACTERS' | 'ALL') {
    const sendPayload = {
      command: NeoSendSocketCommands.generate_turn,
      request_id: this.buildRequestId(),
      payload: {
        chat_type: ChatTypesEnum.TYPE_MU_ROOM,
        chat_id: this.external_id,
        user_name: this.user.user?.username,
        smart_reply: replyType,
        smart_reply_delay: 0,
      },
    };

    // update mesages
    this.publishChatMessages();

    centrifugeChatSocket.send(sendPayload);
  }

  private sendStateUpdateCommand(stateUpdate: PublishStateUpdate) {
    const sendPayload = {
      command: NeoSendSocketCommands.mu_state_update,
      request_id: this.buildRequestId(),
      payload: {
        chat_type: ChatTypesEnum.TYPE_MU_ROOM,
        author: stateUpdate.author,
        participant: stateUpdate.participant,
        type: stateUpdate.updateType,
        participantName: stateUpdate.participantName,
        participantAvatar: stateUpdate.participantAvatar,
        isHuman: stateUpdate.isHuman,
      },
    };

    centrifugeChatSocket.send(sendPayload, this.external_id);
  }
}
