import { v4 as uuidv4 } from 'uuid';
import { ChatInstance } from './ChatInstance';
import { ChatAPI } from './chatAPI';
import {
  ChatEventEnum,
  ChatEventWebsocketErrorPayload,
  ChatInstanceStatusEnum,
  ChatServiceType,
  DUMMY_MSG,
  PublishCommand,
  StateUpdateType,
  TYPING_MSG,
} from './chatManagerTypes';
import {
  AddTurnPayload,
  Candidate,
  FeedbackLabel,
  NeoChatType,
  NeoChatVisibility,
  NeoErrorCodes,
  NeoReceiveSocketCommands,
  NeoSendSocketCommands,
  Turn,
  TurnKey,
  TypingTurn,
} from './chatServiceTypes';
import { getChatSocket } from './chatStack/websocketManager';
import { Participant } from '../types/app-api';
import { neoAPI } from './neoAPI';
import { websocketRegistration } from './chatStack/websocketRegistration';
import { ErrorLogger } from '../DebugLog';
import { selectedChatLanguage } from './chatManagerContext';
import {
  PROCESSING_INDICATOR_TIMEOUT_MS,
  TypingIndicatorErrorTimeoutMS,
} from './chatConstants';

export class ChatInstanceWebSocket extends ChatInstance {
  deleteCallback: (success: boolean) => void;
  useDeleteCallback: (success: boolean) => void;
  lastRequestId: string | null = null;
  abortRequestId: string | null = null;
  // edit
  lastEditRequestId: string | null = null;
  lastEditTurnId: string | null = null;
  // pin
  lastPinRequestId: string | null = null;
  lastPinTurnId: string | null = null;
  // dynamic preference
  stagedFeedbackMap: Partial<Record<FeedbackLabel, 0 | 1>> = {};
  lastGenerateMetadata: {
    turnKey: TurnKey;
    feedbackMap: Record<FeedbackLabel, 0 | 1>;
  } | null = null;
  nextToken?: string;
  typingIndicatorMessaages: TypingTurn[] = [];

  constructor(
    _serviceType: ChatServiceType,
    _external_id: string,
    _user: Participant,
    _onChatEventCallback: (eventType: ChatEventEnum, payload?: any) => void,
    _history_external_id?: string,
    _new_history?: boolean,
    // Always fetches all candidates for all fetched turns.
    // Otherwise, fetches all candidates only for the last AI's turn.
    //    Other turns will be fetched with only the primary candidate.
    _fetch_all_candidates?: boolean,
  ) {
    super(
      _serviceType,
      _external_id,
      _user,
      _onChatEventCallback,
      _history_external_id,
      _new_history,
      _fetch_all_candidates,
    );

    this.setupWebsocket();
    this.deleteCallback = () => {};
    this.useDeleteCallback = (success: boolean) => {
      // call the delete callback
      this.deleteCallback(success);
      // unset it so it doesnt get called again
      this.deleteCallback = () => {};
    };
  }

  // used to replace stub dummy messages with real ones
  replaceDummyTurn(request_id: string, turn: Turn) {
    if (turn.author.is_human) {
      const dummyId = this.turns.findIndex(
        t =>
          t.primary_candidate_id === DUMMY_MSG &&
          t.turn_key.turn_id === request_id,
      );
      if (dummyId > -1) {
        this.turns[dummyId] = turn;
        return true;
      }
    }

    return false;
  }

  removeAllTypingTurns() {
    this.typingIndicatorMessaages.forEach(t => clearTimeout(t.errorTimeout));
    this.typingIndicatorMessaages = [];
  }

  // used to delete typing indicators when a real message is received
  removeTypingTurn(turn?: Turn, request_id?: string) {
    if (turn) {
      const typingIndex = this.typingIndicatorMessaages.findIndex(
        t =>
          t.primary_candidate_id === TYPING_MSG &&
          (t.author.author_id === turn.author.author_id ||
            t.turn_key.turn_id === request_id),
      );
      if (typingIndex > -1) {
        const turn = this.typingIndicatorMessaages.splice(typingIndex, 1)[0];
        clearTimeout(turn.errorTimeout);
      }
    }
  }

  removeTurn(turn_id: string) {
    const turnIndex = this.turns.findIndex(t => t.turn_key.turn_id === turn_id);
    if (turnIndex > -1) {
      this.turns.splice(turnIndex, 1);
    }
  }

  onMessageReceived = (data: any) => {
    console.log('WS Message Recieved', data.command);
    if (data.request_id) {
      this.lastRequestId = data.request_id;
    }

    const isEdit = data.request_id === this.lastEditRequestId;
    const editedIndex =
      isEdit && data.command === NeoReceiveSocketCommands.update_turn
        ? data.turn.candidates.findIndex(
            (c: Candidate) => c.candidate_id === data.turn.primary_candidate_id,
          )
        : -1;

    const isUpdatedPin = data.request_id === this.lastPinRequestId;
    const updatedPinTurnIndex =
      isUpdatedPin && this.lastPinTurnId
        ? this.turns.findIndex(
            (t: Turn) => t.turn_key.turn_id === this.lastPinTurnId,
          )
        : -1;

    switch (data.command) {
      case NeoReceiveSocketCommands.add_turn:
        const payload = data as AddTurnPayload;
        // only append if its not replacing a dummy or loading message
        if (!this.replaceDummyTurn(payload.request_id, payload.turn)) {
          this.removeTypingTurn(payload.turn, payload.request_id);
          this.appendTurn(payload.turn);
        } else {
          this.publishChatMessages();
        }
        break;
      case NeoReceiveSocketCommands.update_turn:
        if (isUpdatedPin && updatedPinTurnIndex > -1) {
          this.updateCandidate(
            this.turns[updatedPinTurnIndex],
            this.turns[updatedPinTurnIndex].turn_key.turn_id,
            data.request_id,
          );
        } else if (isEdit && editedIndex !== -1) {
          this.updateCandidate(
            data.turn,
            data.turn.turn_key.turn_id,
            data.request_id,
            { editedCandidate: data.turn.candidates[editedIndex] },
          );
        } else {
          this.updateCandidate(
            data.turn,
            data.turn.turn_key.turn_id,
            data.request_id,
          );
        }
        break;
      case NeoReceiveSocketCommands.create_chat_response:
        this.chatHistory = data.chat;
        console.log('New chat history created', {
          hasChatHistory: !!this.chatHistory,
        });
        this.fetchMessageHistory();
        break;
      case NeoReceiveSocketCommands.neo_error:
        ErrorLogger.logError(`Neo error from websocket: ${data.error_code}`, {
          extra: { data },
        });
        if (
          data.error_code === NeoErrorCodes.MultiGeneration.errorCode &&
          data.sub_code === NeoErrorCodes.MultiGeneration.subCode
        ) {
          // Someone else is generating a candidate, ours will never complete
          // no op and let the typing indicator expire
        } else {
          const turnIdIndex = isEdit
            ? this.turns.findIndex(
                t => t.turn_key.turn_id === this.lastEditTurnId,
              )
            : -1;
          if (isEdit && turnIdIndex !== -1) {
            this.onMessageError([turnIdIndex]);
          } else {
            if (
              Number(data.error_code) === NeoErrorCodes.TooManyPins.errorCode &&
              Number(data.sub_code) === NeoErrorCodes.TooManyPins.subCode &&
              isUpdatedPin &&
              updatedPinTurnIndex > -1
            ) {
              // undo pinning if we have exceeded the max number of pins
              this.turns[updatedPinTurnIndex].is_pinned = false;
            }

            this.onMessageError();
          }
          this.onChatEventCallback(ChatEventEnum.websocket_error, {
            comment: data.comment,
            error_code: data.error_code,
            sub_code: data.sub_code,
            event_time: new Date().getTime(),
          } as ChatEventWebsocketErrorPayload);
        }

        break;
      case NeoReceiveSocketCommands.remove_turns_response:
        // this is terrible:
        this.useDeleteCallback(true);
        this.fetchMessageHistory(undefined, true);
        break;
      case NeoReceiveSocketCommands.remove_turn:
        this.removeTurn(data.turn_key.turn_id);
        this.useDeleteCallback(true);
        this.publishChatMessages();
        break;
      case NeoReceiveSocketCommands.update_mu_room_response:
        this.onChatEventCallback(ChatEventEnum.updated, {
          updates: data,
        });
        break;
      case NeoReceiveSocketCommands.delete_mu_room:
        this.onChatEventCallback(ChatEventEnum.deleted, { id: data.id });
        break;
      case NeoReceiveSocketCommands.mu_state_update:
        // if its not the current user, add a typing indicator
        if (
          data.payload?.type &&
          data.payload.participant !== this.user.user?.id.toString()
        ) {
          this.addTypingMessage(
            data.payload.participant,
            data.payload.participantName,
            data.payload.isHuman,
            data.request_id,
            data.payload.participantAvatar,
            data.payload.type,
          );
          this.publishChatMessages();
        }
        break;
    }
  };

  onMessageError = (turnIdIndices?: number[]) => {
    // update state of any turns that are currently inflight
    for (let i = 0; i < this.turns.length; i++) {
      if (this.turns[i].state === 'STATE_INFLIGHT') {
        this.turns[i].state = 'STATE_ERROR';
        this.removeAllTypingTurns();
      } else {
        // Don't walk entire history, stop at first non-inflight message
        break;
      }
    }
    // additional turns that we know there are errors for
    for (const index of turnIdIndices ?? []) {
      this.turns[index].state = 'STATE_ERROR';
    }

    this.publishChatMessages();
  };

  setupWebsocket() {
    websocketRegistration.subscribe(
      this.instanceID,
      this.onMessageReceived,
      this.onMessageError,
    );
  }

  async deleteMessages(uuids: string[], _callback: (success: boolean) => void) {
    const sendPayload = {
      command: NeoSendSocketCommands.remove_turns,
      request_id: this.buildRequestId(),
      payload: {
        chat_id: this.chatHistory?.chat_id,
        turn_ids: uuids,
      },
    };
    // this is terrible:
    this.deleteCallback = _callback;
    this.sendSocketMessage(sendPayload);
  }

  async editMessage(
    turn_key: TurnKey,
    candidate_id: string,
    new_raw_content: string,
  ) {
    const sendPayload = {
      command: NeoSendSocketCommands.edit_turn_candidate,
      request_id: this.buildRequestId(),
      payload: {
        turn_key: turn_key,
        current_candidate_id: candidate_id,
        new_candidate_raw_content: new_raw_content,
      },
    };
    this.lastEditRequestId = sendPayload.request_id;
    this.lastEditTurnId = sendPayload.payload.turn_key.turn_id;
    this.sendSocketMessage(sendPayload);
  }

  setTurnPin(turn_key: TurnKey, isPinned: boolean) {
    const sendPayload = {
      command: NeoSendSocketCommands.set_turn_pin,
      request_id: this.buildRequestId(),
      payload: {
        turn_key: turn_key,
        is_pinned: isPinned,
      },
    };
    this.lastPinRequestId = sendPayload.request_id;
    this.lastPinTurnId = sendPayload.payload.turn_key.turn_id;

    this.sendSocketMessage(sendPayload);

    const updatedTurnIndex = this.turns.findIndex(
      (t: Turn) => t.turn_key.turn_id === this.lastPinTurnId,
    );
    if (updatedTurnIndex > -1) {
      this.turns[updatedTurnIndex].is_pinned = isPinned;
    }
  }

  createNewChat() {
    console.log('Creating new chat');
    const sendPayload = {
      command: NeoSendSocketCommands.create_chat,
      request_id: this.buildRequestId(),
      payload: {
        chat: {
          chat_id: uuidv4(),
          creator_id: this.user.user?.id.toString(),
          visibility: NeoChatVisibility.private,
          character_id: this.charData?.external_id,
          type: NeoChatType.direct,
        },
        with_greeting: true,
      },
    };

    this.turns = [];
    this.publishChatMessages();

    this.sendSocketMessage(sendPayload);
  }

  publishChatMessages() {
    // NOTE: this is suboptimal, but we need to make sure that the avatar_url
    // NOTE 2: this is crazy
    if (this.charData?.avatar_file_name) {
      this.turns.map(t => {
        if (!t.author.is_human && !t.author.avatar_url && this.charData) {
          t.author.avatar_url = this.charData.avatar_file_name;
        }
        if (
          t.author.is_human &&
          !t.author.avatar_url &&
          this.user.user?.account?.avatar_file_name
        ) {
          t.author.avatar_url = this.user.user.account.avatar_file_name;
        }
      });
    }

    super.publishChatMessages([
      ...this.typingIndicatorMessaages,
      ...this.turns,
    ]);
  }

  async fetchInitialData(
    external_id: string,
    history_external_id?: string,
    new_history?: boolean,
    fetch_all_candidates?: boolean,
  ) {
    if (this.getStatus() === ChatInstanceStatusEnum.none) {
      // check ws state
      this.setStatus(ChatInstanceStatusEnum.fetchingHistory);
      const characterInfoResponse = await ChatAPI.fetchCharacterInfo(
        external_id,
      );
      if (characterInfoResponse) {
        // get the char data
        this.charData = characterInfoResponse.data.character;

        if (this.charData) {
          if (new_history) {
            // create a new chat
            this.createNewChat();
          } else {
            try {
              // fetch a specific chat
              if (history_external_id != null) {
                const result = await neoAPI.fetchChat(
                  history_external_id,
                );
                if (result?.data.chat != null) {
                  this.chatHistory = result?.data.chat;
                } else {
                  throw new Error('expected a valid chat response from the server');
                }
              } else {
                // fetch recent chats if there's no specific chat
                const result = await neoAPI.fetchRecentChat(
                  this.charData.external_id,
                );
                // ensure we gots the datas
                if ((result?.data?.chats?.length ?? 0) > 0) {
                  console.log({ numChats: result?.data?.chats?.length });
                  this.chatHistory = result.data.chats[0];
                } else {
                  // if there are no chats, create a new one
                  this.createNewChat();
                }
              }

              if (this.chatHistory != null) {
                console.log('Fetching Message History');
                await this.fetchMessageHistory(
                  this.chatHistory.chat_id,
                  undefined,
                  fetch_all_candidates ? {candidate_filter: 'all'} : undefined,
                );
              }
            } catch (error) {
              ErrorLogger.logError('Failed to fetch initial chat data', {
                error,
              });
              this.onChatEventCallback(ChatEventEnum.unrecoverable_error, {
                comment: 'failed to fetch initial chat data',
                external_id,
                history_external_id,
                event_time: new Date().getTime(),
              });

              // set the component to dead
              this.setStatus(ChatInstanceStatusEnum.dead);
            }
          }
        }
      }
    }
  }

  async fetchMessageHistory(
    _history_external_id?: string,
    new_history?: boolean,
    extraParams?: {[key: string]: string},
  ) {
    console.log(`fetchMessageHistory ${this.instanceID}`);

    // If we dont have a chat history, throw an error and kill the instance.
    if (!this.chatHistory) {
      this.onChatEventCallback(ChatEventEnum.unrecoverable_error, {
        comment: 'chat history doesnt exist',
        external_id: this.external_id,
        event_time: new Date().getTime(),
      });
      // Set the component to dead.
      this.setStatus(ChatInstanceStatusEnum.dead);
      return;
    }

    if (this.getStatus() === ChatInstanceStatusEnum.fetchMessages) {
      console.log("Already fetching messages, can't fetch again");
      return;
    }

    const id = this.chatHistory?.chat_id;
    let params: {[key: string]: string} = extraParams ?? {};
    let fetchMore = false;

    this.setStatus(ChatInstanceStatusEnum.fetchMessages);

    // If we have a new_history we want to reset the next token.
    if (new_history) {
      this.nextToken = undefined;
    }

    // Add the next token for pagination if we have one.
    if (this.nextToken) {
      params.next_token = this.nextToken;
      fetchMore = true;
    }

    try {
      const response = await neoAPI.fetchTurns(id, params);

      this.nextToken = response.data?.meta?.next_token;
      this.has_more = !!this.nextToken;

      const newTurns = response.data?.turns ?? [];
      if (fetchMore) {
        this.turns = [...this.turns, ...newTurns];
      } else {
        // if we arent fetching more we want to make sure this message history is the only one
        this.turns = [...newTurns];
        this.updatePrimaryCandidateMapForTurn(this.turns[0]);
      }

      this.publishChatMessages();
      if (this.chatHistory?.chat_id) {
        neoAPI
          .resurrectChat(this.chatHistory?.chat_id)
          .catch(error =>
            ErrorLogger.logError('Failed to resurrect chat', { error }),
          );
      }

      this.setStatus(ChatInstanceStatusEnum.none);
    } catch (error) {
      ErrorLogger.logError('Failed to get chat instance message history', {
        error,
      });
      this.onChatEventCallback(ChatEventEnum.unrecoverable_error, {
        comment: 'failed to list turns',
        external_id: this.external_id,
        event_time: new Date().getTime(),
      });
      // set the component to dead
      this.setStatus(ChatInstanceStatusEnum.dead);
      console.log('Failed to list turns');
    }
  }

  resetFeedbackLabels(turnKey: TurnKey) {
    const feedbackMap = Object.fromEntries(
      Object.values(FeedbackLabel).map(label => [label, 0]),
    ) as Record<FeedbackLabel, 0 | 1>;
    this.lastGenerateMetadata = { turnKey, feedbackMap };
    this.stagedFeedbackMap = {};
  }

  stageFeedbackLabel(label: FeedbackLabel, addOrRemove: 1 | 0) {
    this.stagedFeedbackMap[label] = addOrRemove;
  }

  commitFeedbackLabels() {
    if (!this.lastGenerateMetadata) {
      return;
    }
    const newFeedbackMap = Object.fromEntries(
      Object.values(FeedbackLabel).map(label => [
        label,
        this.stagedFeedbackMap[label] ||
        this.lastGenerateMetadata?.feedbackMap[label]
          ? 1
          : 0,
      ]),
    ) as Record<FeedbackLabel, 0 | 1>;
    this.lastGenerateMetadata = {
      ...this.lastGenerateMetadata,
      feedbackMap: newFeedbackMap,
    };

    this.stagedFeedbackMap = {};
  }

  generateCandidate(ttsEnabled: boolean | undefined) {
    const turnKey = this.turns[0].turn_key;
    if (
      // just in case: reset lastGenerateMetadata if the current turnKey doesn't match the stored turnKey
      // this shouldn't happen though because we should always be resetting after create and generate turn
      (turnKey.turn_id !== this.lastGenerateMetadata?.turnKey.turn_id &&
        turnKey.chat_id !== this.lastGenerateMetadata?.turnKey.chat_id) ||
      // feedbackMap shouldn't be null
      !this.lastGenerateMetadata?.feedbackMap
    ) {
      this.resetFeedbackLabels(turnKey);
    } else {
      this.commitFeedbackLabels();
    }

    const sendPayload = {
      command: NeoSendSocketCommands.generate_turn_candidate,
      request_id: this.buildRequestId(),
      payload: {
        tts_enabled: ttsEnabled ?? false,
        selected_language: selectedChatLanguage ?? '',
        character_id: this.charData?.external_id,
        user_name: this.user.name,
        turn_key: {
          turn_id: this.turns[0].turn_key.turn_id,
          chat_id: this.turns[0].turn_key.chat_id,
        },
        previous_annotations: this.lastGenerateMetadata?.feedbackMap,
      },
    };

    // this turn is now back inflight
    this.turns[0].state = 'STATE_INFLIGHT';

    this.sendSocketMessage(sendPayload);
  }

  _sendSocketMessage(
    messageText: string | undefined,
    primary_candidate_id: string | undefined,
    ttsEnabled: boolean | undefined,
  ) {
    const turnKey = this.turns[0]?.turn_key;
    // just in case: reset lastGenerateMetadata if the current turnKey doesn't match the stored turnKey
    // this shouldn't happen though because we should always be resetting after create and generate turn
    if (
      turnKey &&
      turnKey.turn_id !== this.lastGenerateMetadata?.turnKey.turn_id &&
      turnKey.chat_id !== this.lastGenerateMetadata?.turnKey.chat_id
    ) {
      this.resetFeedbackLabels(turnKey);
    } else {
      this.commitFeedbackLabels();
    }

    const newTurnId = uuidv4();
    const newTurnKey = {
      turn_id: newTurnId,
      chat_id: this.chatHistory?.chat_id ?? '',
    };
    const sendPayload = {
      command: NeoSendSocketCommands.create_and_generate_turn,
      request_id: this.buildRequestId(),
      payload: {
        num_candidates: 1,
        tts_enabled: ttsEnabled ?? false,
        selected_language: selectedChatLanguage ?? '',
        character_id: this.charData?.external_id,
        user_name: this.user.name,
        turn: {
          turn_key: newTurnKey,
          author: {
            author_id: this.user.user?.id.toString(),
            is_human: true,
            name: this.user.name,
          },
          candidates: [
            {
              candidate_id: newTurnId,
              raw_content: messageText,
            },
          ],
          primary_candidate_id: newTurnId,
        },
        previous_annotations: this.lastGenerateMetadata?.feedbackMap,
        update_primary_candidate: primary_candidate_id
          ? {
              candidate_id: primary_candidate_id,
              turn_key: {
                turn_id: this.turns[0].turn_key.turn_id,
                chat_id: this.chatHistory?.chat_id,
              },
            }
          : undefined,
      },
    };

    // add user dummy message
    if (messageText) {
      this.addDummyMessage(messageText, sendPayload.request_id);
    }
    // add loading message
    this.addTypingMessage(
      this.charData?.external_id ?? '',
      this.charData?.name ?? '',
      false,
      sendPayload.request_id,
      this.charData?.avatar_file_name,
    );

    // update mesages
    this.publishChatMessages();

    this.sendSocketMessage(sendPayload);

    this.resetFeedbackLabels(newTurnKey);
  }

  sendChatMessage(publishCmd: PublishCommand) {
    switch (publishCmd.type) {
      case 'generate_candidate':
        this.generateCandidate(publishCmd.ttsEnabled);
        break;
      case 'stage_feedback_label':
        this.stageFeedbackLabel(
          publishCmd.feedbackLabel,
          publishCmd.addOrRemove,
        );
        break;
      case 'abort':
        this.abortCandidateGeneration();
        break;
      case 'create_and_generate':
        this._sendSocketMessage(
          publishCmd.message,
          publishCmd.primaryCandidateId,
          publishCmd.ttsEnabled,
        );
        break;
      case 'edit_turn_candidate':
        this.editMessage(
          publishCmd.turnKey,
          publishCmd.candidateId,
          publishCmd.newRawContent,
        );
        break;
      case 'set_turn_pin':
        this.setTurnPin(publishCmd.turnKey, publishCmd.isPinned);
        break;
      default:
        console.log(
          `ChatInstanceWebSocket: ignoring ${publishCmd.type} send command`,
        );
    }
  }

  // Sets the primary candidate of the most recent turn.
  updatePrimaryCandidateMap(uuid: string, idx: number): void {
    super.updatePrimaryCandidateMap(uuid, idx);
    const { turn_id } = this.turns[0].turn_key;
    
    this.setPrimaryCandidateOfTurn(turn_id, idx);
  }

  updatePrimaryCandidateMapForTurn(turn?: Turn): void {
    // Update the primary candidate map for this turn
    if (turn && turn.candidates.length > 1) {
      const primaryCandidateId = turn.primary_candidate_id;
      const index = turn.candidates.findIndex(
        c => c.candidate_id === primaryCandidateId,
      );
      if (index > -1) {
        // No need to call our override and update the backend
        // Call the base class method to update the primary candidate map only
        super.updatePrimaryCandidateMap(turn.turn_key.turn_id, index);
      }
    }
  }

  // Sets the primary candidate of any turn.
  setPrimaryCandidateOfTurn(turn_id: string, candidateIndex: number) {
    const turn = this.turns.find(t => t.turn_key.turn_id === turn_id);

    if (!turn) return;

    const candidate = turn.candidates[candidateIndex];

    if (!candidate) return;

    const candidate_id = candidate.candidate_id;

    if (
      candidate_id &&
      candidate_id !== TYPING_MSG &&
      candidate_id !== DUMMY_MSG &&
      candidate.is_final
    ) {
      turn.primary_candidate_id = candidate_id;
      this.sendSocketMessage({
        command: NeoSendSocketCommands.update_primary_candidate,
        payload: {
          candidate_id,
          turn_key: turn.turn_key,
        },
      });
    }
  }

  abortCandidateGeneration() {
    if (this.lastRequestId) {
      const abortPayload = {
        command: NeoSendSocketCommands.abort_generation,
        request_id: this.lastRequestId,
      };
      this.abortRequestId = this.lastRequestId;
      this.lastRequestId = null;
      this.sendSocketMessage(abortPayload);
    }
  }

  sendSocketMessage(payload: any) {
    getChatSocket().send(payload);
  }

  cleanup(): void {
    super.cleanup();
    websocketRegistration.unsubscribe(this.instanceID);
  }

  // adds a dummy message to the turns that will be replaced once a
  // real message returns from the server
  addDummyMessage(messageText: string, request_id: string) {
    if (
      this.user.user?.id.toString() &&
      this.hasDummyMessage(this.user.user?.id.toString())
    ) {
      return;
    }
    this.turns = [
      {
        turn_key: {
          turn_id: request_id,
          chat_id: this.chatHistory?.chat_id ?? '',
        },
        author: {
          author_id: this.user.user?.id.toString() ?? '',
          is_human: true,
          name: this.user.user?.account?.name ?? '',
        },
        candidates: [
          {
            candidate_id: DUMMY_MSG,
            raw_content: messageText,
            create_time: new Date().toISOString(),
            fresh: false,
            is_final: true,
          },
        ],
        create_time: new Date().toISOString(),
        last_update_time: new Date().toISOString(),
        state: 'STATE_INFLIGHT',
        primary_candidate_id: DUMMY_MSG,
      },
      ...this.turns,
    ];
  }

  // adds or updates a typing indicator to the turns that will be replaced once a
  // real message returns from the server
  // or times out
  addTypingMessage(
    id: string,
    name: string,
    isHuman: boolean,
    request_id: string,
    avatarUrl?: string,
    type: StateUpdateType = 'typing',
  ) {
    const typingIndex = this.typingIndicatorMessaages.findIndex(
      t => t.primary_candidate_id === TYPING_MSG && t.author.author_id === id,
    );

    if (typingIndex > -1) {
      const typingTurn = this.typingIndicatorMessaages[typingIndex];

      this.resetTypingTurnTimeout(typingTurn, request_id);
    } else {
      if (
        this.user.user?.id.toString() &&
        this.hasDummyMessage(this.user.user?.id.toString())
      ) {
        return;
      }

      this.addTypingTurn(id, name, isHuman, request_id, avatarUrl, type);
    }
  }

  hasDummyMessage = (id: string) => {
    return (
      this.turns.findIndex(
        t => t.author.author_id === id && t.primary_candidate_id === TYPING_MSG,
      ) > -1
    );
  };

  /**
   * Creates a new typing turn.
   */
  private createNewTypingTurn(
    id: string,
    name: string,
    isHuman: boolean,
    request_id: string,
    avatarUrl?: string,
    type: StateUpdateType = 'typing',
  ): TypingTurn {
    const newTypingTurn = {
      turn_key: {
        turn_id: request_id,
        chat_id: this.chatHistory?.chat_id ?? '',
      },
      author: {
        author_id: id,
        is_human: isHuman,
        name: name,
        avatar_url: avatarUrl ?? '',
      },
      candidates: [
        {
          candidate_id: TYPING_MSG,
          raw_content: '',
          create_time: new Date().toISOString(),
          fresh: true,
          is_final: true,
        },
      ],
      create_time: new Date().toISOString(),
      last_update_time: !isHuman
        ? new Date(
            new Date().getTime() + 10000, // add an additional 10 seconds to AI timeouts
          ).toISOString()
        : new Date().toISOString(),
      state: 'STATE_INFLIGHT',
      primary_candidate_id: TYPING_MSG,
      errorTimeout: -1,
      type,
    } as TypingTurn;

    this.setTypingTurnTimeout(newTypingTurn, request_id);

    return newTypingTurn;
  }

  /**
   * Resets the timeout for the typing turn.
   */
  private resetTypingTurnTimeout(turn: TypingTurn, request_id: string) {
    clearTimeout(turn.errorTimeout);
    this.setTypingTurnTimeout(turn, request_id);
    turn.last_update_time = new Date().toISOString();
  }

  /**
   * Sets the timout for the typing turn based on the typing turn type.
   */
  private setTypingTurnTimeout(turn: TypingTurn, request_id: string) {
    if (turn.type === 'processing') {
      // @ts-ignore NEEDED to avoid breaking builds.
      turn.errorTimeout = setTimeout(
        () => this.onLongProcesingIndicator(turn, request_id),
        PROCESSING_INDICATOR_TIMEOUT_MS,
      );
    } else {
      // @ts-ignore NEEDED to avoid breaking builds. Thinks setInterval returns NodeJS.Timer
      turn.errorTimeout = setTimeout(
        () => this.onLongTypingIndicator(),
        TypingIndicatorErrorTimeoutMS,
      );
    }
  }

  /**
   * Updates the typing turns with the new typing turn.
   */
  private addTypingTurn(
    id: string,
    name: string,
    isHuman: boolean,
    request_id: string,
    avatarUrl?: string,
    type: StateUpdateType = 'typing',
  ) {
    const newTypingTurn = this.createNewTypingTurn(
      id,
      name,
      isHuman,
      request_id,
      avatarUrl,
      type,
    );

    this.typingIndicatorMessaages = [
      newTypingTurn,
      ...this.typingIndicatorMessaages,
    ];
  }

  /**
   * On long lasting typing indicator event handler.
   */
  private onLongTypingIndicator() {
    ErrorLogger.logError('Typing message displayed for too long');
  }

  /**
   * On long lasting processing indicator event handler.
   */
  private onLongProcesingIndicator(turn: TypingTurn, request_id: string) {
    this.removeTypingTurn(turn, request_id);
    this.publishChatMessages();
  }
}
