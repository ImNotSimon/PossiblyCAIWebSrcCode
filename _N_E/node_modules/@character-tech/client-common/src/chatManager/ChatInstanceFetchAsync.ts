// import {
//   EventNames,
//   logEvent,
//   LogEventHowOften,
// } from '@src/analytics/EventLogger'; // TODO: reenable this somehow? dep inj?

import { v4 as uuidv4 } from 'uuid';
import { Participant } from '../types/app-api';
import { ChatAPI } from './chatAPI';
import { ChatInstance } from './ChatInstance';
import {
  ChatEventEnum,
  ChatInstanceStatusEnum,
  ChatServiceType,
  DUMMY_MSG,
  PublishCommand,
  PublishLegacy,
  USR_MSG,
} from './chatManagerTypes';
import { clearAsyncInterval, setAsyncInterval } from './chatManagerUtils';
// import {
//   finishSimplePerformanceTrace,
//   logEvent,
//   startSimplePerformanceTrace,
// } from "@src/analytics/EventLogger";
// import { EventNames } from "@src/analytics/EventNames";
import {
  DebugEventType,
  LogDebugError,
  LogDebugEvent,
  LogDebugWarning,
} from '../DebugLog';
import { axios } from '../lib/axios';

export const LOADING_MSG = 'loading_msg';

export class ChatInstanceFetchAsync extends ChatInstance {
  abortedUUID: string | undefined;
  lastUUID: string | undefined;

  constructor(
    _serviceType: ChatServiceType,
    _external_id: string,
    _user: Participant,
    _onChatEventCallback: (eventType: ChatEventEnum, payload?: any) => void,
    _history_external_id?: string,
    _new_history?: boolean,
  ) {
    super(
      _serviceType,
      _external_id,
      _user,
      _onChatEventCallback,
      _history_external_id,
      _new_history,
    );
    this.publishChatMessages();
  }

  async deleteMessages(uuids: string[], callback: (success: boolean) => void) {
    if (this.chatHistory) {
      try {
        const success = await ChatAPI.deleteMessages(
          this.chatHistory?.chat_id,
          uuids,
        );

        // lets go regrab the message history
        this.fetchMessageHistory(undefined, true);

        callback(success);
      } catch (e) {
        // logEvent(EventNames.Messages.RemoveError);
        LogDebugError('failed to delete messages', e, uuids);
      }
    }
  }

  sendChatMessage(publishCmd: PublishCommand) {
    if (publishCmd.type !== 'legacy') {
      throw new Error(
        `Only legacy publish command is supported by ChatInstanceFetchAsync: ${publishCmd.type}`,
      );
    }
    const {
      messageText,
      generatingCandidates,
      primaryCandidateId,
      retryLastUserMsg,
      abortCurrentMsg,
    } = publishCmd as unknown as PublishLegacy;

    // halt any additional requests
    if (this.getStatus() !== ChatInstanceStatusEnum.cancelling) {
      if (this.getStatus() !== ChatInstanceStatusEnum.none) {
        this.abortedUUID = this.lastUUID;
        this.setStatus(ChatInstanceStatusEnum.cancelling);
      } else if (!generatingCandidates) {
        // delete the dummy message
        // but only if its not the greeting (the first message)
        if (this.messages.length > 1 && !retryLastUserMsg) {
          if (this.messages[this.messages.length - 1].uuid === DUMMY_MSG) {
            this.messages.splice(this.messages.length - 1, 1);
          }
        }
        this.publishChatMessages();
      }

      if (!abortCurrentMsg) {
        if (generatingCandidates) {
          //   dispatch(setGeneratingCandidateAction(true));
        } else {
          //######## APPEND USER MESSAGE (if its not empty) & TYPING MESSAGE
          if (!retryLastUserMsg && messageText !== '') {
            this.appendMessage({
              text: messageText ?? '',
              deleted: false,
              uuid: USR_MSG,
              id: -1,
              image_prompt_text: '',
              image_rel_path: '',
              is_alternative: false,
              responsible_user__username: '',
              src__character__avatar_file_name:
                this.user?.avatar_file_name ?? '',
              src__is_human: true,
              src__name: this.user?.name ?? '',
              src__user__username: this.user?.user?.username ?? '',
              src_char: {
                participant: this.user,
                avatar_file_name: this.user?.avatar_file_name ?? '',
              },
              badge_reason: '',
              clientUUID: uuidv4(),
              fresh: true,
            });
          }

          // todo: streamline this
          this.appendMessage({
            text: '',
            deleted: false,
            uuid: LOADING_MSG,
            id: -2,
            image_prompt_text: '',
            image_rel_path: '',
            is_alternative: false,
            responsible_user__username: '',
            src__character__avatar_file_name:
              this.charData?.avatar_file_name ?? '',
            src__is_human: false,
            inProgress: true,
            src__name: this.charData?.name ?? '',
            src__user__username: '',
            src_char: {
              participant: this.charData,
              avatar_file_name: this.charData?.avatar_file_name ?? '',
            },
            badge_reason: '',
            clientUUID: uuidv4(),
            fresh: true,
          });
        }

        if (this.getStatus() !== ChatInstanceStatusEnum.cancelling) {
          this._sendChatMessageLegacyFetchNoWhile(
            messageText,
            generatingCandidates,
            primaryCandidateId,
            retryLastUserMsg,
          );
        } else {
          const retryInterval = setInterval(() => {
            if (this.getStatus() !== ChatInstanceStatusEnum.cancelling) {
              this._sendChatMessageLegacyFetchNoWhile(
                messageText,
                generatingCandidates,
                primaryCandidateId,
              );
              clearInterval(retryInterval);
            }
          }, 100);
        }
      } else {
        this.addDummyMessage();

        this.publishChatMessages();
      }
    }
    // this._sendSocketMessage(messageText);
  }

  // outWhileInterval: number;

  // LEGACY CHAT STREAM THAT DOESNT BLOCK THE THREAD
  async _sendChatMessageLegacyFetchNoWhile(
    messageText: string | undefined,
    generatingCandidates: boolean,
    primaryCandidateUUID?: string,
    retryLastUserMsg?: boolean,
  ) {
    try {
      // TODO: re-enable performance tracing
      // const { transaction, span } = startSimplePerformanceTrace(
      //   EventNames.Performance.FirstChunkLatency,
      //   "mobile.src.context.chatManager.ChatInstanceFetchAsync._sendChatMessageLegacyFetchNoWhile"
      // );
      this.setStatus(ChatInstanceStatusEnum.sending);

      this.replaceDummyUUID();
      //#######

      const rankingMethod: 'random' | 'classifier' = 'random'; // can be "random" or "classifier"

      const defaultStreamEveryNSteps = 16; // If you change here, also change the default in server/chat/views/views.py.

      const body = {
        history_external_id: this.chatHistory?.chat_id,
        character_external_id: this.charData?.external_id,
        text: messageText, //isProactive ? null : userText,
        tgt: this.charData?.participant__user__username,
        ranking_method: rankingMethod,
        staging: false, //staging,

        enable_tti: false, //enableTextToImage,
        stream_every_n_steps: defaultStreamEveryNSteps,
        is_proactive: false, //isProactive,
        image_rel_path: '', //userImagePath,
        image_description: '', //userImageDescription,
        image_description_type: '', //userImageDescriptionType,
        image_origin_type: '', //userImageOriginType,
        voice_enabled: false, //characterVoiceEnabled,

        parent_msg_uuid: generatingCandidates
          ? this.getLastMessageUUID()
          : null,
        primary_msg_uuid: !generatingCandidates ? primaryCandidateUUID : null,
        seen_msg_ids: [], // this is unused I believe
        num_candidates: 1,
        filter_candidates: null,
        give_room_introductions: true,
        initial_timeout: null,
        insert_beginning: null,
        livetune_coeff: null,
        model_server_address: null,
        override_prefix: null,
        override_rank: null,
        prefix_limit: null,
        prefix_token_limit: null,
        rank_candidates: null,
        retry_last_user_msg_id: null,
        unsanitized_characters: null,
        retry_last_user_msg_uuid: retryLastUserMsg
          ? this.getLastMessageUUID()
          : null,
      };

      if (!generatingCandidates) {
        //   dispatch(setCharTypingAction(true));
        //   dispatch(setCharMessageFullyRenderedAction(false));
        //   primaryCandidateRef.current = null;
        //   dispatch(setSeenCandidateIdsAction([]));
      }

      const url = `${axios().defaults.baseURL}/chat/streaming/`;
      let data: any = null;

      const axiosHeaders = axios().defaults.headers.common;
      const headers: HeadersInit = {};

      for (const key in axiosHeaders) {
        const header = axiosHeaders[key];
        if (header) {
          headers[key] = header.toString();
        }
      }

      const response = await fetch(url, {
        method: 'POST',
        headers,
        // @ts-ignore part of the dark magic to get streaming working off web
        reactNative: { textStreaming: true },
        body: JSON.stringify(body),
      });

      // @ts-ignore part of the dark magic to get streaming working off web
      const reader = response?.body?.getReader();

      reader?.closed
        .then(() => {
          LogDebugEvent('Stream reader closed', DebugEventType.log);
        })
        .catch(() => {
          LogDebugEvent('Stream reader error', DebugEventType.warn);
          this.onChatEventCallback(ChatEventEnum.receive_fail, {
            message: 'Failed to decode message',
            external_id: this.external_id,
          });
          this.handleServerAbort(generatingCandidates);
          clearAsyncInterval(outWhileInterval);
        });

      let decoded_value = '';
      let first_iteration = true;
      let decode_error_count = 0;
      const decode_error_limit = 120;

      // const max_iterations = 1000000;
      // let iteration = 0;
      // let letter_count = 0;
      // let audioEnded = null;

      // let streamingChatError = '';
      // let runningStart = performance.now();
      let outWhileInterval = setAsyncInterval(async () => {
        // Abort previous request generating candidate request if a new request was made
        // if (shouldAbortChatRequest(generatingCandidates)) {
        //   // console.log('ABORTING CHAT');
        //   break;
        // }

        // console.log('running', performance.now() - runningStart);
        // runningStart = performance.now();
        // done  - true if the stream has already given you all its data.
        // value - some data. Always undefined when done is true.
        let readValue = '';
        try {
          // const start = performance.now();
          // @ts-expect-error err
          const { value, done } = await reader.read();
          // console.log('read time:', performance.now() - start);
          // @ts-expect-error err
          readValue = value;
          if (done) {
            // console.log('done', this.outWhileInterval);
            // clearAsyncInterval(this.outWhileInterval);
            // this.status = ChatInstanceStatusEnum.none;
            // this.finalizeMessage(data);
            // return;
          }
        } catch (e) {
          console.log('reader error:', e);
        }

        try {
          // @ts-ignore part of the dark magic to get streaming working off web
          decoded_value += new TextDecoder().decode(readValue);
        } catch (e) {
          LogDebugWarning('failed to decode text', e);
        }

        if (first_iteration) {
          // finishSimplePerformanceTrace(transaction, span);
          try {
            const first_parsed_value = JSON.parse(decoded_value);
            if (first_parsed_value?.replies?.length > 0) {
              this.backfillUUIds(
                first_parsed_value?.replies[0].uuid,
                first_parsed_value.last_user_msg_uuid,
              );
            } else {
              this.backfillUUIds('', first_parsed_value.last_user_msg_uuid);
            }

            if (first_parsed_value?.force_login) {
              this.sendGuestLimitMessage();

              // Note(irwan): This should be refactored as it is actually confusing.
              // Lazy users are not authenticated on the front-end (isAuthenticated is false)
              // so they can't navigate to signup. Instead they are shown the login modal.
              // navigate(`/signup${buildUrlParams({ force_login: true })}`);
            }
            first_iteration = false;
          } catch (e) {
            decode_error_count++;
            if (decode_error_count > decode_error_limit) {
              try {
                this.onChatEventCallback(ChatEventEnum.receive_fail, {
                  message: 'Failed to decode message',
                  external_id: this.external_id,
                });

                this.handleServerAbort(generatingCandidates);
              } catch (e_inner) {
                console.log('Failed to gracefully abort:', e_inner);
              }
              clearAsyncInterval(outWhileInterval);

              return;
            }
            console.log('First Iteration Error:', e);
            // console.log(decoded_value, decode_error_count);
            // try only works when the user is a lazy user + user has maxed out messages quota
            // otherwise this will crash and silently fail
          }
        }

        const nl_index = decoded_value.indexOf('\n');
        if (nl_index === -1) {
          return;
        }
        const json_string = decoded_value.substring(0, nl_index);

        decoded_value = decoded_value.substring(nl_index + 1);

        if (
          this.abortedUUID &&
          data?.replies &&
          data.replies.length > 0 &&
          data.replies[0].uuid === this.abortedUUID
        ) {
          await ChatAPI.abortChatMessage(
            this.chatHistory?.chat_id ?? '',
            this.abortedUUID,
            data.replies[0].text.length,
          );

          this.abortedUUID = undefined;
          this.finalizeMessage(data, true);
          clearAsyncInterval(outWhileInterval);
          this.setStatus(ChatInstanceStatusEnum.none);

          return;
        }

        try {
          data = JSON.parse(json_string);
        } catch (e) {
          LogDebugWarning('failed to parse data:', e);
        }

        // SERVER-SIDE ABORT LOGIC
        if (data?.abort) {
          if (data?.error === 'unauthorized') {
            this.onChatEventCallback(ChatEventEnum.abort, {
              message: 'unauthorized',
              uuid: data.uuid,
              external_id: this.external_id,
            });

            this.handleServerAbort(generatingCandidates);
          } else if (data?.error === 'No eligible candidates') {
            this.onChatEventCallback(ChatEventEnum.filter, {
              message: 'No eligible candidates',
              uuid: data.uuid,
              external_id: this.external_id,
            });

            this.handleServerAbort(generatingCandidates);
          } else if (data.error) {
            console.log('Unexpected message generation error', data.error);
            this.onChatEventCallback(ChatEventEnum.receive_fail, {
              message: 'Unexpected message generation error',
              uuid: data.uuid,
              external_id: this.external_id,
            });

            this.handleServerAbort(generatingCandidates);
          }

          // LogDebugWarning(JSON.stringify(data));
          // throw new Error('data.abort');
          clearAsyncInterval(outWhileInterval);
        }

        // Populate candidate missing IDs with fake negative IDs,
        // to help in debugging the problem in logs.
        if (data?.replies) {
          this.populateMissingCandidatesIds(data.replies, -1);
          // markAsAnnotatable(data.replies);
          // dispatch(setCharTypingAction(false));

          const full_reply_text = data.replies[0].text;

          this.lastUUID = data.replies[0].uuid;

          this.updateMessage(full_reply_text, data.replies[0].uuid);

          if (data.is_final_chunk) {
            clearAsyncInterval(outWhileInterval);
            this.setStatus(ChatInstanceStatusEnum.none);
            this.finalizeMessage(data);

            if (data?.replies?.length > 0) {
              this.onChatEventCallback(ChatEventEnum.message_finished, {
                uuid: data.replies[0].uuid,
                participant_name: this.charData?.participant__name,
                messageText: data.replies[0].text,
                external_id: this.charData?.external_id,
              });
            }
          }
        }

        if (!reader) {
          clearAsyncInterval(outWhileInterval);
          this.setStatus(ChatInstanceStatusEnum.none);
          this.finalizeMessage(data);
          return;
        }
      }, 16);
    } catch (e) {
      LogDebugWarning('legacy chat stream error:', e);
    }
  }

  handleServerAbort = (generatingCandidates: boolean) => {
    this.popMessage();
    if (generatingCandidates) {
      this.addDummyMessage();
      this.publishChatMessages();
    }
    this.setStatus(ChatInstanceStatusEnum.none);
  };

  replaceDummyUUID = () => {
    let updatedMsgs = [...this.messages];

    if (updatedMsgs.length > 1) {
      const lastCharMessageIdx = updatedMsgs.findIndex(
        m => m.uuid === DUMMY_MSG,
      );

      if (lastCharMessageIdx > -1) {
        updatedMsgs[lastCharMessageIdx].uuid = LOADING_MSG;
      }
    }

    this.messages = [...updatedMsgs];
    this.publishChatMessages();
  };

  backfillUUIds = (uuid: string, last_user_msg_id?: string) => {
    let updatedMsgs = [...this.messages];

    if (uuid && updatedMsgs.length > 1) {
      const lastCharMessageIdx = updatedMsgs.findIndex(
        m => m.uuid === LOADING_MSG,
      );

      if (lastCharMessageIdx > -1) {
        updatedMsgs[lastCharMessageIdx].uuid = uuid;
      }
    }

    if (last_user_msg_id && updatedMsgs.length > 1) {
      const lastUserMessageIdx = updatedMsgs.findIndex(m => m.uuid === USR_MSG);

      if (lastUserMessageIdx > -1) {
        updatedMsgs[lastUserMessageIdx].uuid = last_user_msg_id;
      }
    }

    this.messages = [...updatedMsgs];
    this.publishChatMessages();
  };

  // HELPER FUNCTIONS FOR LEGACY CHAT
  populateMissingCandidatesIds = (candidates: any[], fake_id: number) => {
    try {
      if (candidates && typeof candidates === 'object') {
        for (const candidate of candidates) {
          if (!candidate.id) {
            candidate.id = fake_id;
          }
        }
      } else {
        console.log(
          'candidates are not any[], are instead',
          candidates,
          typeof candidates,
        );
      }
    } catch (e) {
      LogDebugWarning('failed to populate missing candidate ids:', e);
    }
  };

  getLastMessageUUID() {
    if (this.messages) {
      for (let j = this.messages.length - 1; j >= 0; j--) {
        if (!this.messages[j].deleted && this.messages[j].src__is_human) {
          return this.messages[j].uuid;
        }
      }
    }
  }

  addDummyMessage = () => {
    this.messages.push({
      text: '',
      deleted: false,
      id: -1,
      uuid: DUMMY_MSG,
      image_prompt_text: '',
      image_rel_path: '',
      is_alternative: true,
      responsible_user__username: '',
      src__character__avatar_file_name: this.charData?.avatar_file_name ?? '',
      src__is_human: false,
      src__name: this.charData?.name ?? '',
      src__user__username: '',
      src_char: {
        participant: this.charData,
        avatar_file_name: this.charData?.avatar_file_name ?? '',
      },
      badge_reason: '',
      clientUUID: uuidv4(),
      fresh: true,
    });
  };

  finalizeMessage(data: any, cancelled?: boolean) {
    try {
      if (this.messages) {
        let updatedMsgs = [...this.messages];

        if (data?.replies[0] && updatedMsgs.length > 1) {
          const lastCharMessageIdx = updatedMsgs.findIndex(
            m => m.uuid === data.replies[0].uuid,
          );
          if (lastCharMessageIdx > -1) {
            updatedMsgs[lastCharMessageIdx].id = data.replies[0].id;
            updatedMsgs[lastCharMessageIdx].inProgress = false;
            updatedMsgs[lastCharMessageIdx].fresh = true;
            updatedMsgs[lastCharMessageIdx].text = data.replies[0].text;
            updatedMsgs[lastCharMessageIdx].image_rel_path =
              data.replies[0].image_rel_path;
            if (updatedMsgs[lastCharMessageIdx].image_rel_path) {
              // logEvent(
              //   EventNames.Messages.ReceivedGeneratedImage,
              //   null,
              //   null,
              //   LogEventHowOften.Always,
              // );
            }
          }

          this.messages = [...updatedMsgs];
        }

        if (data.last_user_msg_id > 0 && updatedMsgs.length > 1) {
          const lastUserMessageIdx = updatedMsgs.findIndex(m => m.id === -2);
          if (lastUserMessageIdx > -1) {
            updatedMsgs[lastUserMessageIdx].id = data.last_user_msg_id;
          }
          this.messages = [...updatedMsgs];
        }

        // add the dummy message
        if (!cancelled) {
          this.addDummyMessage();
        }
        this.publishChatMessages();
      }
    } catch (e) {
      LogDebugWarning('finalize message error:', e);
    }
  }

  updateMessage(text: string, uuid: string) {
    try {
      const messageToUpdate = this.messages.findIndex(m => m.uuid === uuid);

      if (messageToUpdate > -1) {
        const messages = [...this.messages];
        messages[messageToUpdate].text = text;
        messages[messageToUpdate].uuid = uuid;
        messages[messageToUpdate].inProgress = true;
        this.messages = messages;

        this.publishChatMessages();
      } else {
        LogDebugWarning(
          'couldnt find message to update, gonna try loading message:',
          uuid,
        );
        const messageToUpdateFallback = this.messages.findIndex(
          m => m.uuid === LOADING_MSG,
        );

        if (messageToUpdateFallback > -1) {
          const messages = [...this.messages];
          messages[messageToUpdateFallback].text = text;
          messages[messageToUpdateFallback].uuid = uuid;
          messages[messageToUpdateFallback].inProgress = true;
          this.messages = messages;

          LogDebugWarning('successfully updated but with fallback! oh no!');
          this.publishChatMessages();
        }
      }
    } catch (e) {
      LogDebugWarning('failed to updateMessage:', e);
    }
  }

  sendGuestLimitMessage() {
    try {
      const messageToUpdate = this.messages.findIndex(
        m => m.uuid === LOADING_MSG,
      );

      if (messageToUpdate > -1) {
        const messages = [...this.messages];
        messages[messageToUpdate].force_signin = true;
        this.messages = messages;

        this.publishChatMessages();
      } else {
        LogDebugWarning('failed to find dummy message');
      }
    } catch (e) {
      LogDebugWarning('failed to updateMessage:', e);
    }
  }
}
