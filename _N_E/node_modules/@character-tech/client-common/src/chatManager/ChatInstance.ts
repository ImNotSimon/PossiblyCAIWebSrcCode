// import {
//   EventNames,
//   logEvent,
//   LogEventHowOften,
// } from '@src/analytics/EventLogger'; // TODO: hook this back up

import { v4 as uuidv4 } from 'uuid';
import { Character, Message, Participant } from '../types/app-api';
import { ChatAPI } from './chatAPI';
import {
  ChatEventEnum,
  ChatInstanceStatusEnum,
  ChatServiceType,
  ChatUpdateCallback,
  DUMMY_MSG,
  PublishCommand,
} from './chatManagerTypes';
import {
  convertChatHistoryToChat,
  processRawMessageToTurns,
  processViewChatMessages,
} from './chatManagerUtils';
import { Chat, Turn } from './chatServiceTypes';
import { LogDebugError, LogDebugWarning } from '../DebugLog';
import { ViewChatMessage } from '../types/types';

// TODO: tighten up the interface here
export interface ChatInterface {
  messages: Message[]; // list of legacy messages (these are converted to turns before publish)
  turns: ViewChatMessage[]; // list of view chat messages
  subscriberCallbacks: ChatUpdateCallback[];
  serviceType: ChatServiceType;
  chatHistory?: Chat;
  has_more: boolean;

  isInitialized: () => boolean;

  subscribe(callback: ChatUpdateCallback): () => void;

  publishChatMessages: (turnsOverride?: ViewChatMessage[]) => void;
  onChatEventCallback: (eventType: ChatEventEnum, payload?: any) => void;
  getStatus: () => ChatInstanceStatusEnum;
  cleanup: () => void;

  sendChatMessage: (publishCmd: PublishCommand) => void;

  deleteMessages: (
    uuids: string[],
    callback: (success: boolean) => void,
  ) => void;

  refreshHistory: (newHistory?: boolean) => void;

  setUser(user: Participant): unknown;

  fetchMessageHistory: (
    history_external_id?: string,
    new_history?: boolean,
  ) => void;

  updatePrimaryCandidateMap: (uuid: string, idx: number) => void;
  setPrimaryCandidateOfTurn: (turnId: string, candidateId: number) => void;
}

// This object is used to handle an 'instance' of chat
// it handles all of the state & network logic
// as well as dispatching updates to the correct subscribers
export class ChatInstance implements ChatInterface {
  messages: Message[]; // list of legacy messages (these are converted to turns before publish)
  turns: ViewChatMessage[]; // list of turns
  primaryCandidateMap: Record<string, number>; // map of primaryCandidates set by the client for clientside memory

  external_id: string;
  history_external_id?: string;
  subscriberCallbacks: ChatUpdateCallback[];
  chatHistory?: Chat;
  charData?: Character;
  user: Participant;

  has_more: boolean;
  next_page: number;

  serviceType: ChatServiceType;

  onChatEventCallback: (eventType: ChatEventEnum, payload?: any) => void;
  wsRetryAttemps: number = 0;
  instanceID: string;

  private status: ChatInstanceStatusEnum;

  constructor(
    _serviceType: ChatServiceType,
    _external_id: string,
    _user: Participant,
    _onChatEventCallback: (eventType: ChatEventEnum, payload?: any) => void,
    _history_external_id?: string,
    _new_history?: boolean,
    _fetch_all_candidates?: boolean,
  ) {
    this.instanceID = _external_id.slice(-12); // take up to the last 12 characters of the external_id
    this.serviceType = _serviceType;
    this.onChatEventCallback = _onChatEventCallback;
    this.messages = [];
    this.turns = [];
    this.external_id = _external_id;
    this.history_external_id = _history_external_id;
    this.subscriberCallbacks = [];
    this.user = _user;
    this.status = ChatInstanceStatusEnum.none;

    this.has_more = true;
    this.next_page = -1;

    this.primaryCandidateMap = {};
    // go and get the character info and history
    this.fetchInitialData(_external_id, _history_external_id, _new_history, _fetch_all_candidates);
  }

  isInitialized() {
    return !!this.chatHistory;
  }

  subscribe(callback: ChatUpdateCallback): () => void {
    this.subscriberCallbacks.push(callback);
    return () => {
      this.subscriberCallbacks = this.subscriberCallbacks.filter(
        cb => cb !== callback,
      );
    };
  }

  publishChatMessages(turnsOverride?: ViewChatMessage[]) {
    // we need to process the messages into turns

    let turns = turnsOverride ?? this.turns;
    // TODO: handle this more gracefully maybe?
    if (this.serviceType === ChatServiceType.Legacy) {
      if (this.messages?.length > 0) {
        turns = processRawMessageToTurns(
          this.messages,
          this.chatHistory?.chat_id,
        );
      } else {
        // if we dont have new messages we still need to set the turns to empty
        turns = [];
      }
    }

    turns = processViewChatMessages(turns);

    this.subscriberCallbacks.forEach(callback =>
      callback(turns, this.primaryCandidateMap),
    );

    this.onChatEventCallback(ChatEventEnum.messages, {
      messages: turns,
    });
  }

  async deleteMessages(
    _uuids: string[],
    _callback: (success: boolean) => void,
  ) {
    LogDebugError('implementer must implement this');
  }

  async fetchInitialData(
    external_id: string,
    history_external_id?: string,
    new_history?: boolean,
    _fetch_all_candidates?: boolean,
  ) {
    if (this.status === ChatInstanceStatusEnum.none) {
      this.setStatus(ChatInstanceStatusEnum.fetchingHistory);
      const characterInfoResponse = await ChatAPI.fetchCharacterInfo(
        external_id,
      );
      if (characterInfoResponse) {
        this.charData = characterInfoResponse.data.character;
        if (this.charData) {
          // GET THE HISTORY OR CREATE IT
          try {
            let historyResponse;

            if (new_history) {
              historyResponse = await ChatAPI.fetchChatCreateHistory(
                external_id,
              );
            } else {
              historyResponse = await ChatAPI.fetchChatContinuedHistory(
                external_id,
                history_external_id,
              );
            }

            this.chatHistory = convertChatHistoryToChat(historyResponse.data);
          } catch (e: any) {
            // History does not exist or unauthorized; create new one.
            if (e.response?.status >= 400 && e.response?.status < 500) {
              const historyResponse = await ChatAPI.fetchChatCreateHistory(
                external_id,
              );
              this.chatHistory = convertChatHistoryToChat(historyResponse.data);
            } else {
              // TODO: error handling
            }
          } finally {
            this.setStatus(ChatInstanceStatusEnum.none);
            this.has_more = true;
            this.next_page = -1;
            this.fetchMessageHistory(history_external_id, new_history);
          }
        }
      }
    }
  }

  async fetchMessageHistory(
    history_external_id?: string,
    new_history?: boolean,
  ) {
    const chat_id = history_external_id || this.chatHistory?.chat_id;
    if (
      (this.has_more || new_history) &&
      this.status === ChatInstanceStatusEnum.none &&
      chat_id
    ) {
      try {
        // if this is a new history we want to reset the pagination values
        if (new_history) {
          this.next_page = -1;
          this.has_more = true;
        }

        this.setStatus(ChatInstanceStatusEnum.fetchMessages);
        const response = await ChatAPI.fetchChatMessageHistory(
          chat_id,
          this.next_page !== -1 ? this.next_page : undefined,
        );
        if (new_history) {
          // if its a new history we wanna wipe out the old one
          this.messages = response.data.messages ?? [];
        } else {
          // else we want to append
          this.messages = [...(response.data.messages ?? []), ...this.messages];
        }
        this.has_more = response.data.has_more;
        this.next_page = response.data.next_page;

        if (this.messages.length > 0) {
          // add those client uuids for the client to work with
          this.messages = this.messages.map(m => ({
            ...m,
            clientUUID: uuidv4(),
          }));
        }
        // Add dummy message for candidates
        if (
          this.messages.length > 1 &&
          !this.messages[this.messages.length - 1].src__is_human
        ) {
          this.messages.push({
            text: '',
            deleted: false,
            id: -1,
            uuid: DUMMY_MSG,
            image_prompt_text: '',
            image_rel_path: '',
            is_alternative: true,
            responsible_user__username: '',
            src__character__avatar_file_name:
              this.charData?.avatar_file_name ?? '',
            src__is_human: false,
            src__name: this.charData?.name ?? '',
            src__user__username: '',
            src_char: {
              participant: this.charData,
              avatar_file_name: this.charData?.avatar_file_name ?? '',
            },
            badge_reason: '',
            clientUUID: uuidv4(),
          });
        }

        this.publishChatMessages();
      } catch (e) {
        LogDebugWarning('failed to get messages', e);
        this.onChatEventCallback(ChatEventEnum.receive_fail, {
          message: 'Failed to get messages',
          external_id: this.external_id,
        });
      } finally {
        this.setStatus(ChatInstanceStatusEnum.none);
      }
    }
  }

  appendMessage(message: Message) {
    this.messages.push(message);
    this.publishChatMessages();
  }

  appendTurn(turn: Turn) {
    const turnIndex = this.turns.findIndex(
      t => t.turn_key.turn_id === turn.turn_key.turn_id,
    );
    if (turnIndex === -1) {
      this.turns = [turn, ...this.turns];
      this.publishChatMessages();
    } else {
      LogDebugWarning('duplicate turns detected during add turn');
    }
  }

  updateTurn(turn: Turn, uuid: string) {
    const turnToUpdate = this.turns.findIndex(m => m.turn_key.turn_id === uuid);
    if (turnToUpdate > -1) {
      // merge left new turn
      this.turns[turnToUpdate] = { ...turn, ...this.turns[turnToUpdate] };
      this.publishChatMessages();
    } else {
      LogDebugWarning("Couldn't find turn to update");
    }
  }

  updateCandidate(
    turn: Turn,
    uuid: string,
    request_id?: string,
    metadata?: any,
  ) {
    const turnToUpdate = this.turns.findIndex(m => m.turn_key.turn_id === uuid);
    // TODO: understand if the first candidate will always be the one updating
    // or if more than one candidate can be updated at the same time
    const candidateToUpdate = metadata?.editedCandidate ?? turn.candidates[0];

    candidateToUpdate.request_id = request_id;
    candidateToUpdate.fresh = true;

    if (turnToUpdate > -1 && candidateToUpdate) {
      // `...` candidates lack an ID, so don't match on it if that's the case
      const candidateIndex = candidateToUpdate.candidate_id
        ? this.turns[turnToUpdate].candidates.findIndex(
            c => c.candidate_id === candidateToUpdate.candidate_id,
          )
        : -1;

      if (candidateIndex > -1) {
        this.turns[turnToUpdate].candidates[candidateIndex] = candidateToUpdate;
      } else {
        this.turns[turnToUpdate].candidates.push(candidateToUpdate);
      }

      this.publishChatMessages();

      if (metadata?.editedCandidate) {
        const editedIndex =
          candidateIndex > -1
            ? candidateIndex
            : this.turns[turnToUpdate].candidates.length - 1;

        this.updatePrimaryCandidateMap(turn.turn_key.turn_id, editedIndex);
        this.onChatEventCallback(ChatEventEnum.message_edited, {
          turnId: turn.turn_key.turn_id,
          editedIndex,
        });
      }
    } else {
      LogDebugWarning("Couldn't find turn to update");
    }
  }

  popMessage() {
    this.messages.pop();
    this.publishChatMessages();
  }

  refreshHistory(newHistory?: boolean) {
    if (this.charData) {
      // this.messages = []; // dont wipe out the current history
      this.publishChatMessages();
      this.fetchInitialData(this.charData?.external_id, undefined, newHistory);
    }
  }

  cleanup() {}

  sendChatMessage(_publishCmd: PublishCommand) {
    throw new Error('sendChatMessage must be implemented by extended class');
  }

  updatePrimaryCandidateMap(uuid: string, idx: number) {
    this.primaryCandidateMap[uuid] = idx;
  }

  setPrimaryCandidateOfTurn(_turnId: string, _candidateId: number) {}

  buildRequestId() {
    return uuidv4().slice(0, 24) + this.instanceID;
  }

  setStatus(status: ChatInstanceStatusEnum) {
    // as long as we arent dead we can still do stuff
    if (this.status !== ChatInstanceStatusEnum.dead) {
      this.status = status;
    }
  }

  getStatus() {
    return this.status;
  }

  setUser(user: Participant) {
    this.user = user;
  }
}
