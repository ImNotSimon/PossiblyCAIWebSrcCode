import {
  Centrifuge,
  ConnectedContext,
  DisconnectedContext,
  ErrorContext,
  PublicationContext,
  Subscription,
  TransportEndpoint,
} from 'centrifuge';
import {
  getCentrifugeEmulationAddress,
  getCentrifugeSseAddress,
  getCentrifugeTimeoutMs,
  getCentrifugeWsAddress,
  getEventSource,
} from '../../lib/axiosConstants';
import { __global } from '../../lib/globals';
import { ChatEventEnum, WebsocketStatus } from '../chatManagerTypes';
import { extractChatInstanceUUID } from '../chatManagerUtils';
import { NeoReceiveSocketCommands } from '../chatServiceTypes';
import { BaseWebsocketManager } from './baseWebsocketManager';
import { AppChatSocket } from './websocketManager';
import { websocketRegistration } from './websocketRegistration';
import { ErrorLogger } from '../../DebugLog';

type RoomSubscription = {
  subscription: Subscription;
  instanceId: string;
};

/*
Centrifuge works by invoking RPCs on the server, which then respond
over the various websocket subscriptions. Currently we only use the 
users channel user#<user_id> to receive chat messages. But we can 
expand this to other subscriptions in the future.
*/

export class CentrifugeManager
  extends BaseWebsocketManager
  implements AppChatSocket
{
  centrifuge: Centrifuge;
  userSubscription: Subscription | undefined;
  roomSubscriptions: Record<string, RoomSubscription>;

  // While experimenting with centrifuge for everything we'll only publish while in the experiment.
  // That way if we get unexpected behavior in prod we can disable the experiment.
  // Remove conditional once centrifuge is the only websocket implementation.
  publishRpcResponses: boolean;

  constructor(
    onChatEventCallback: (eventType: ChatEventEnum, payload?: any) => void,
    publishRpcResponses: boolean,
    userId?: number,
  ) {
    super(onChatEventCallback);

    this.publishRpcResponses = publishRpcResponses;

    const transports: TransportEndpoint[] = [
      {
        transport: 'websocket',
        endpoint: getCentrifugeWsAddress(),
      },
      {
        transport: 'sse',
        endpoint: getCentrifugeSseAddress(),
      },
    ];

    const eventsource = getEventSource();
    if (!eventsource) {
      console.warn(
        'EventSource not provided, Centrifuge SSE fallback might not work',
      );
    }

    this.centrifuge = new Centrifuge(transports, {
      timeout: getCentrifugeTimeoutMs(),
      eventsource,
      emulationEndpoint: getCentrifugeEmulationAddress(),
    });
    this.centrifuge.on('connected', (context: ConnectedContext) => {
      console.log('centrifuge connected', context);
      // let room listeners know that the websocket is connected
      Object.values(this.roomSubscriptions).forEach(sub => {
        websocketRegistration.socketConnected(sub.instanceId);
      });
      this.onChatEventCallback(ChatEventEnum.websocket_status, {
        status: WebsocketStatus.open,
      });
    });
    this.centrifuge.on('disconnected', (context: DisconnectedContext) => {
      console.log('centrifuge disconnected', context);
      this.checkAuthentication({ message: context.reason, code: context.code });
      this.onChatEventCallback(ChatEventEnum.websocket_status, {
        status: WebsocketStatus.closed,
      });
    });
    this.centrifuge.on('error', (context: ErrorContext) => {
      ErrorLogger.logError('centrifuge error', {
        error: context.error,
        extra: { context },
      });
      this.onChatEventCallback(ChatEventEnum.websocket_status, {
        status: WebsocketStatus.error,
      });
      this.onChatEventCallback(ChatEventEnum.websocket_error, {
        comment: context.error.message,
        error_code: context.error.code,
      });
    });

    if (userId) {
      this.userSubscription = this.centrifuge.newSubscription(`user#${userId}`);
      this.userSubscription.on('publication', ctx =>
        this.handlePublication(ctx),
      );
      this.userSubscription.subscribe();
    } else {
      console.log('Centrifuge not subscribing to user channel');
    }
    this.roomSubscriptions = {};

    this.setupWebsocket();
  }

  subscribeToRoom(chatId: string, instanceId: string) {
    let subscription = this.roomSubscriptions[chatId]?.subscription;
    const channel = this.buildChannelName(chatId);
    if (!subscription) {
      console.log(`Subscribing to room: ${channel}`);
      subscription = this.centrifuge.newSubscription(channel);
      subscription.on('publication', ctx => this.handlePublication(ctx));
    } else {
      console.log(`Already subscribed to room: ${channel}`);
    }
    this.roomSubscriptions[chatId] = { subscription, instanceId };

    // subscribe in case we've previously unsubscribed, multiple calls are a no op
    subscription.subscribe();
  }

  unsubscribeFromRoom(chatId: string) {
    this.roomSubscriptions[chatId]?.subscription?.unsubscribe();
  }

  async send(payload: Record<string, any>, chatId?: string) {
    this.restartTTLTimer();
    await this.reconnectWebsocket();
    const debugWSPayload = __global.getDebugWSPayload();
    if (!!debugWSPayload && payload.payload) {
      payload.payload = { ...payload.payload, ...debugWSPayload };
    }

    try {
      // if a chat id has been passed in, publish to the room channel
      console.log('Sending centrifuge payload', {
        command: payload?.command,
        chatId,
      });
      if (chatId) {
        await this.centrifuge.publish(this.buildChannelName(chatId), payload);
        return;
      }

      const response = await this.centrifuge
        // command is read from the payload, not the value passed in
        .rpc('unused_command', payload);

      if (this.publishRpcResponses) {
        this.publishResponseData(response.data);
      }
    } catch (error: any) {
      ErrorLogger.logError('centrifuge send error', {
        error,
        extra: { code: error.code, message: error.message },
      });
      const subscriberId = extractChatInstanceUUID(payload.request_id);

      // if the error contains a message try to parse it to see if we need to special case it
      if (error.message) {
        try {
          const message = JSON.parse(error.message);
          console.log('error message', message);
          if (message?.command === NeoReceiveSocketCommands.neo_error) {
            // if the error messaage contains a neo_error, send it as a message to the client
            websocketRegistration.publish(message, subscriberId);
          } else {
            // otherwise raise it as a generic error
            websocketRegistration.raiseError(subscriberId);
          }
          return;
        } catch (err) {
          // couldn't extract additional details from message, raise generic error
          websocketRegistration.raiseError(subscriberId);
        }
      }
      // fallback to raising error
      websocketRegistration.raiseError(subscriberId);
    }
  }

  async setupWebsocket() {
    await this.authenticate();
    // this no-ops if already connected
    this.centrifuge.connect();
  }

  disconnectWebsocket() {
    this.centrifuge.disconnect();
  }

  async reconnectWebsocket() {
    await this.setupWebsocket();
  }

  private buildChannelName(chatId: string) {
    return `room:${chatId}`;
  }

  private handlePublication(context: PublicationContext) {
    console.log('Centrifuge publication', {
      command: context.data?.command,
      requestId: context.data?.request_id,
    });
    this.restartTTLTimer();
    this.publishResponseData(context.data);
  }

  private publishResponseData(data: any) {
    // Update messages don't have a request id, fallback to id
    const id = data?.request_id ?? data?.id;
    if (!id) {
      return;
    }
    try {
      const subscriberId = extractChatInstanceUUID(id);
      websocketRegistration.publish(data, subscriberId);
    } catch (error: any) {
      ErrorLogger.logError('centrifuge publication error', { error });
    }
  }
}
