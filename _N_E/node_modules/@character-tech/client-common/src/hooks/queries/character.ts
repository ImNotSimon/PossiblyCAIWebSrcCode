import { useMutation, useQuery, useQueryClient } from './setup';
import { axios } from '../../lib/axios';
import {
  Character,
  CharacterDetailed,
  CreateCharacterResponse,
  RecentChatShunt,
  UpdateCharacterResponse,
} from '../../types/app-api';
import { useCallback } from 'react';
import { legacyAPI } from '../../chatManager/legacyAPI';
import { hiddenCharacters } from '../../state/signals';
import { useSignalValue } from 'signals-react-safe';
import { characterQueries, discoveryQueries, userQueries } from './baseQueries';
import { neoAPI } from '../../chatManager/neoAPI';

const sanitizeCharacterField = (lst: { uuid: string; text: string }[]) =>
  lst.map(el => {
    const { text } = el;
    if (text[0] === '"' && text[text.length - 1] === '"') {
      return { ...el, text: text.slice(1, -1) };
    }
    return el;
  });

export const useGenerateCharacterField = (needSanitization: boolean = true) => {
  const mutation = useMutation(
    async (data: {
      field_to_generate: string;
      num_candidates?: number;
      metadata: any;
    }) => {
      const promises = Array.from({ length: data.num_candidates ?? 1 }, () =>
        axios().post<{
          result: { uuid: string; text: string }[];
        }>('chat/character/generate/field', {
          field_to_generate: data.field_to_generate,
          num_candidates: data.num_candidates ?? 1,
          metadata: data.metadata,
        }),
      );

      const responses = await Promise.all(promises);

      const results = responses.map(response =>
        needSanitization
          ? sanitizeCharacterField(response.data.result)
          : response.data.result,
      );

      return results.flat();
    },
  );
  return mutation;
};

export interface AvatarOption {
  url: string;
  content: string;
  art_form: string;
  styles: string[];
}

export const useGenerateAvatarOptions = () => {
  const mutation = useMutation(
    async (data: { name: string; num_candidates: number }) => {
      const response = await axios().post<{
        result: AvatarOption[];
      }>('chat/character/generate-avatar-options', data);
      return response.data;
    },
  );
  return mutation;
};

export const useCreateCharacter = () => {
  const queryClient = useQueryClient();
  const mutation = useMutation(
    async (data: Partial<CharacterDetailed>) => {
      return (
        await axios().post<CreateCharacterResponse>('/chat/character/create/', {
          title: data.title,
          name: data.name,
          identifier: data.identifier,
          categories: data.categories,
          visibility: data.visibility,
          copyable: data.copyable,
          description: data.description,
          greeting: data.greeting,
          definition: data.definition,
          avatar_rel_path: data.avatar_rel_path,
          img_gen_enabled: data.img_gen_enabled,
          base_img_prompt: data.base_img_prompt,
          strip_img_prompt_from_msg: data.strip_img_prompt_from_msg,
          voice_id: data.voice_id,
          default_voice_id: data.default_voice_id,
        })
      ).data.character;
    },
    {
      onSuccess: () => {
        // invalidate the users chars since we now have a new character
        queryClient.invalidateQueries(userQueries.characters.keys('user'));
      },
    },
  );
  return mutation;
};

export const useUpdateCharacter = () => {
  const queryClient = useQueryClient();
  const mutation = useMutation(
    async (data: Partial<CharacterDetailed>) => {
      return (
        await axios().post<UpdateCharacterResponse>('/chat/character/update/', {
          external_id: data.external_id,
          title: data.title,
          name: data.name,
          categories: data.categories,
          visibility: data.visibility,
          copyable: data.copyable,
          description: data.description,
          greeting: data.greeting,
          definition: data.definition,
          avatar_rel_path: data.avatar_rel_path,
          img_gen_enabled: data.img_gen_enabled,
          base_img_prompt: data.base_img_prompt,
          strip_img_prompt_from_msg: data.strip_img_prompt_from_msg,
          voice_id: data.voice_id,
          default_voice_id: data.default_voice_id,
        })
      ).data.character;
    },
    {
      onSuccess: character => {
        // invalidate the users chars since we now have updated a character
        queryClient.invalidateQueries(userQueries.characters.keys('user'));

        // invalidate the detailed/info char since this characters has been updated
        queryClient.invalidateQueries(
          characterQueries.detailed.keys(character.external_id),
        );
        queryClient.invalidateQueries(
          characterQueries.info.keys(character.external_id),
        );
      },
    },
  );
  return mutation;
};

export const useCharacterDetailed = (externalId?: string) => {
  const query = useQuery({
    enabled: !!externalId,
    queryKey: characterQueries.detailed.keys(externalId ?? ''),
    queryFn: () => characterQueries.detailed.queryFn(externalId),
    staleTime: Infinity,
  });
  return {
    ...query,
    detailedCharacter: query.data?.data?.character,
  };
};

export const useCharacterInfo = (externalId?: string) => {
  const query = useQuery({
    enabled: !!externalId,
    queryKey: characterQueries.info.keys(externalId ?? ''),
    queryFn: () => characterQueries.info.queryFn(externalId),
    staleTime: Infinity,
  });
  return {
    ...query,
    character: query.data?.data?.character,
  };
};

export const useHideCharacter = (externalId: string) => {
  const query = useQueryClient();

  const hideCharacter = useCallback(async () => {
    await legacyAPI.hideCharacter(externalId);
    hiddenCharacters.value = hiddenCharacters.value.concat(externalId);
  }, [externalId, query]);

  return hideCharacter;
};

export const useHideCharacterChat = () => {
  const queryClient = useQueryClient();
  const mutation = useMutation(
    async ({ externalId }: { externalId: string }) => {
      return await neoAPI.hideCharacterChat(externalId);
    },
    {
      onSuccess: () => {
        queryClient.invalidateQueries(discoveryQueries.recent.keys(true));
      },
    },
  );
  return mutation;
};

export const useFilterHiddenCharacters = () => {
  const hiddenCharactersValue = useSignalValue(hiddenCharacters);
  const filterHiddenCharacters = useCallback(
    <T extends Character | RecentChatShunt>(characters?: T[]): T[] => {
      return (characters ?? []).filter(
        (character: T) =>
          !hiddenCharactersValue.includes(
            (character as Character).external_id ??
              (character as RecentChatShunt).character_id,
          ),
      ) as T[];
    },
    [hiddenCharactersValue],
  );
  return filterHiddenCharacters;
};

export const useRecommendedationsForCharacter = (character_id?: string) => {
  const query = useQuery({
    queryKey: characterQueries.recommended.keys(character_id ?? ''),
    queryFn: async () => characterQueries.recommended.queryFn(character_id),
    staleTime: Infinity,
    enabled: !!character_id,
  });

  return {
    ...query,
    recommendedCharacters: query.data?.data.characters ?? [],
  };
};
