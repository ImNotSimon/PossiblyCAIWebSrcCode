import React, { useCallback, useContext, useEffect, useRef } from 'react';
import { Participant } from '../types/app-api';
import { setupAxios } from '../lib/axios';
import { ChatInstanceFetchAsync } from './ChatInstanceFetchAsync';
import { ChatInstanceWebSocket } from './ChatInstanceWebsocket';
import {
  ChatEventCallback,
  ChatEventEnum,
  ChatInstanceStatusEnum,
  ChatServiceType,
  ChatUpdateCallback,
  PublishCommand,
} from './chatManagerTypes';
import { ChatInterface } from './ChatInstance';
import {
  reconnectAppChatSocket,
  setupAppChatSocket,
} from './chatStack/websocketManager';
import { setNeoHost, setOriginId } from '../lib/axiosConstants';
import { RoomInstanceWebSocket } from './RoomInstanceWebsocket';
import { LogErrorImpl, setErrorLogger } from '../DebugLog';

import {
  SetChatProviderUser as SetChatProviderUserImpl,
  currentUser,
} from './chatProviderUser';

interface ChatContext {
  /** Allows consumers to subscribe to a chat instance and receive messages */
  subscribe: (
    _chatId: string,
    _onUpdate: ChatUpdateCallback,
    _serviceType: ChatServiceType,
    _externalHistory?: string | undefined,
    _new_history?: boolean,
    _forceRefresh?: boolean,
    _fetchAllCandidates?: boolean,
  ) => { currentStatus: ChatInstanceStatusEnum; unsubscribe: () => void };
  /** Allows consumers to send commands to chat instances */
  publish: (_external_id: string, _publishCmd: PublishCommand) => void;
  /** Allows consumers to send messages to refresh a given chat instance */
  refresh: (
    _external_id: string,
    _newHistory?: boolean,
    _forceRefresh?: boolean,
  ) => void;
  refreshUser: (_user: Participant) => void;
  /** Allows consumers to subscribe to a specific type of chat event */
  subscribeChatEvents: (
    _eventType: ChatEventEnum,
    _callback: (eventType: ChatEventEnum, payload?: any) => void,
  ) => () => void;
  /** Commands the Chat Manager to delete instances that are not in focus, and only keep the referenced instance */
  removeUnfocusedInstances: (external_id: string) => void;
  /** Commands a chat instance to delete a specific batch of messages */
  deleteMessages: (
    _external_id: string,
    _uuids: string[],
    _callback: (success: boolean) => void,
  ) => void;
  /** Commands a chat instance to get chat messages. Pagination will be handled internally automagically */
  getChatMessages: (_external_id: string) => void;
  /** Injector to provide Chat Manager with pre-configured Axios client for things like auth headers and interceptors */
  setupAxios: (_axiosInstance: any) => void;
  /** Allows clients to update the primary candidate map */
  updatePrimaryCandidateMap: (
    _external_id: string,
    _uuid: string,
    _idx: number,
  ) => void;
  setPrimaryCandidateOfTurn: (
    _external_id: string,
    _turn_id: string,
    _idx: number,
  ) => void;
  /** Forces the websocket to reconnect if not already connected */
  reconnect: () => void;
  /** Update chat stack configuration */
  updateConfiguration: ({
    neoHost,
    selectedLanguage,
  }: {
    neoHost?: string;
    selectedLanguage?: string | undefined;
  }) => void;
}

const UninitializedContext = () =>
  console.error('Context has not been initialized');

const defaultState: ChatContext = {
  subscribe: (
    _chatIndex: string,
    _onUpdate: ChatUpdateCallback,
    _serviceType: ChatServiceType,
    _externalHistory?: string | undefined,
    _new_history?: boolean,
    _forceRefresh?: boolean,
    _fetchAllCandidates?: boolean,
  ) => {
    UninitializedContext();
    return {
      currentStatus: ChatInstanceStatusEnum.none,
      unsubscribe: () => {},
    };
  },
  publish: (_external_id: string, _publishCmd: PublishCommand) =>
    UninitializedContext,
  refresh: (
    _external_id: string,
    _newHistory?: boolean,
    _forceRefresh?: boolean,
  ) => UninitializedContext,
  refreshUser: (_user: Participant) => UninitializedContext,
  subscribeChatEvents: (
    _eventType: ChatEventEnum,
    _callback: (eventType: ChatEventEnum, payload?: any) => void,
  ) => UninitializedContext,
  removeUnfocusedInstances: (_external_id: string) => UninitializedContext,
  deleteMessages: (
    _external_id: string,
    _uuids: string[],
    _callback: (success: boolean) => void,
  ) => UninitializedContext,
  getChatMessages: (_external_id: string) => UninitializedContext,
  setupAxios: (_axiosInstance: any) => UninitializedContext,
  updatePrimaryCandidateMap: (
    _external_id: string,
    _uuid: string,
    _idx: number,
  ) => UninitializedContext,
  setPrimaryCandidateOfTurn: (
    _external_id: string,
    _turn_id: string,
    _idx: number,
  ) => UninitializedContext,
  reconnect: () => UninitializedContext,
  updateConfiguration: () => UninitializedContext,
};

// The Chat Context handles all of the subscriptions
// and publishing new chat messages from the components
export const ChatContext = React.createContext<ChatContext>(defaultState);

export const SetChatProviderUser = (user: Participant) => {
  SetChatProviderUserImpl(user);
};

export let selectedChatLanguage: string | undefined;

const SetSelectedChatLanguage = (language: string | undefined) => {
  selectedChatLanguage = language;
};

export const ChatContextProvider = ({
  children,
  getAxiosInstance,
  neoEnabled,
  originId, // Unique ID for the origin of the chat ie. "<ios|android|web>-<gitsha>"
  userId,
  useCentrifuge,
  useCentrifugeByDefault,
  errorLogger,
}: {
  children: any;
  getAxiosInstance: any;
  neoEnabled: boolean;
  originId: string;
  userId?: number;
  useCentrifuge?: boolean;
  useCentrifugeByDefault?: boolean;
  errorLogger?: LogErrorImpl;
}) => {
  const chatInstances = React.useRef<Record<string, ChatInterface>>({});
  const chatEventSubscribers = useRef<Record<string, ChatEventCallback<any>[]>>(
    {},
  );
  const axiosInitialized = useRef(false);

  // in order to get ahead of any race conditions, we need to make sure that
  // that axios is setup before we start using since the first render is called
  // before useEffects which trigger after a render
  if (!axiosInitialized.current) {
    setupAxios(getAxiosInstance);
    axiosInitialized.current = true;
  }

  useEffect(() => {
    setOriginId(originId);
  }, [originId]);

  useEffect(() => {
    setErrorLogger(errorLogger);
  }, [errorLogger]);

  useEffect(() => {
    return () => {
      for (const instanceId in chatInstances.current) {
        if (chatInstances.current[instanceId]) {
          // console.log(instanceId, "cleaned up");
          deleteInstance(instanceId);
        }
      }
    };
  }, []);

  const onChatEventCallback = useCallback(
    (eventType: ChatEventEnum, payload?: any) => {
      if (chatEventSubscribers.current[eventType]) {
        for (const instantId in chatEventSubscribers.current[eventType]) {
          if (chatEventSubscribers.current[eventType][instantId]) {
            chatEventSubscribers.current[eventType][instantId](
              eventType,
              payload,
            );
          }
        }
      }
    },
    [],
  );

  useEffect(() => {
    setupAxios(getAxiosInstance);
    if (neoEnabled) {
      setupAppChatSocket(
        onChatEventCallback,
        userId,
        useCentrifuge,
        useCentrifugeByDefault,
      );
      console.log('Chat Manager Initalized');
    }
  }, [
    onChatEventCallback,
    neoEnabled,
    getAxiosInstance,
    userId,
    useCentrifuge,
    useCentrifugeByDefault,
  ]);

  const updateConfiguration = useCallback(
    ({
      neoHost,
      selectedLanguage,
    }: {
      neoHost?: string;
      selectedLanguage?: string | undefined;
    }) => {
      if (neoHost) {
        setNeoHost(neoHost);
        if (neoEnabled) {
          setupAppChatSocket(
            onChatEventCallback,
            userId,
            useCentrifuge,
            useCentrifugeByDefault,
          );
        }
      }

      SetSelectedChatLanguage(selectedLanguage);
    },
    [userId, useCentrifuge, useCentrifugeByDefault, neoEnabled],
  );

  // used for listeners of any chat item update
  const subscribeChatEvents = useCallback(
    (eventType: ChatEventEnum, callback: ChatEventCallback<any>) => {
      if (!chatEventSubscribers.current[eventType]) {
        chatEventSubscribers.current[eventType] = [];
      }
      chatEventSubscribers.current[eventType].push(callback);
      return () => {
        chatEventSubscribers.current[eventType] = chatEventSubscribers.current[
          eventType
        ].filter(cb => cb !== callback);
      };
    },
    [],
  );

  const deleteInstance = useCallback((external_id: string) => {
    if (chatInstances.current[external_id]) {
      chatInstances.current[external_id].cleanup();
      delete chatInstances.current[external_id];
    }
  }, []);

  const subscribe = useCallback(
    (
      external_id: string,
      callback: ChatUpdateCallback,
      serviceType: ChatServiceType,
      external_history_id?: string | undefined,
      new_history?: boolean | undefined,
      forceRefresh?: boolean,
      fetchAllCandidates?: boolean,
    ) => {
      // instantiate if it doesnt exist
      if (!chatInstances.current[external_id]) {
        // console.log("creating new instance");
        chatInstances.current[external_id] = buildChatInstance(
          serviceType,
          external_id,
          currentUser,
          onChatEventCallback,
          external_history_id,
          new_history,
          fetchAllCandidates,
        );
      } else if (
        (external_history_id &&
          chatInstances.current[external_id]?.chatHistory &&
          chatInstances.current[external_id]?.chatHistory?.chat_id !==
            external_history_id) ||
        forceRefresh
      ) {
        // TODO: all the old subscribers are out of luck but ¯\_(ツ)_/¯
        // delete the old one
        deleteInstance(external_id);
        // console.log("creating new instance", forceRefresh, external_history_id);

        chatInstances.current[external_id] = buildChatInstance(
          serviceType,
          external_id,
          currentUser,
          onChatEventCallback,
          external_history_id,
          new_history,
          fetchAllCandidates,
        );
      }

      const unsubscribe =
        chatInstances.current[external_id].subscribe(callback);
      // TODO: this actually publishes to all the current subs but ¯\_(ツ)_/¯
      chatInstances.current[external_id].publishChatMessages();

      return {
        currentStatus: chatInstances.current[external_id].getStatus(),
        unsubscribe,
      };
    },
    [deleteInstance],
  );

  const refreshUser = useCallback((user: Participant) => {
    for (const external_id of Object.keys(chatInstances.current)) {
      chatInstances.current[external_id].setUser(user);
      chatInstances.current[external_id].refreshHistory();
    }
  }, []);

  // refreshes the history of a target external_id
  const refresh = useCallback(
    (external_id: string, newHistory?: boolean, forceRefresh?: boolean) => {
      if (chatInstances.current[external_id]) {
        if (newHistory) {
          // go and notify all the subs that there are empty messages now
          chatInstances.current[external_id].turns = [];
          chatInstances.current[external_id].messages = [];
          chatInstances.current[external_id].publishChatMessages();
        }

        // rebuild this bad boy from scratch
        if (forceRefresh) {
          // store the callbacks and service type for rebuilt instance
          const subscriberCallbacks =
            chatInstances.current[external_id].subscriberCallbacks;
          const chatEventCallbacks =
            chatInstances.current[external_id].onChatEventCallback;
          const serviceType =
            newHistory && neoEnabled // Creating a new history and neo is enabled force neo
              ? ChatServiceType.Neo
              : chatInstances.current[external_id].serviceType;

          deleteInstance(external_id);

          chatInstances.current[external_id] = buildChatInstance(
            serviceType,
            external_id,
            currentUser,
            onChatEventCallback,
            undefined,
            newHistory,
          );
          chatInstances.current[external_id].subscriberCallbacks =
            subscriberCallbacks;
          chatInstances.current[external_id].onChatEventCallback =
            chatEventCallbacks;
          chatInstances.current[external_id].publishChatMessages();
        } else {
          chatInstances.current[external_id].refreshHistory(newHistory);
        }
      }
    },
    [deleteInstance],
  );

  const removeUnfocusedInstances = useCallback(
    (focused_external_id: string) => {
      for (const instanceId in chatInstances.current) {
        if (
          chatInstances.current[instanceId] &&
          instanceId !== focused_external_id
        ) {
          deleteInstance(instanceId);
        }
      }
    },
    [deleteInstance],
  );

  const publish = useCallback(
    (external_id: string, publishCmd: PublishCommand) => {
      if (chatInstances.current[external_id]) {
        chatInstances.current[external_id].sendChatMessage(publishCmd);
      }
    },
    [],
  );

  const updatePrimaryCandidateMap = useCallback(
    (external_id: string, uuid: string, idx: number) => {
      if (chatInstances.current[external_id]) {
        chatInstances.current[external_id].updatePrimaryCandidateMap(uuid, idx);
      }
    },
    [],
  );

  const setPrimaryCandidateOfTurn = useCallback(
    (external_id: string, turn_id: string, idx: number) => {
      if (chatInstances.current[external_id]) {
        chatInstances.current[external_id].setPrimaryCandidateOfTurn(turn_id, idx);
      }
    },
    [],
  );

  const deleteMessages = useCallback(
    (
      external_id: string,
      uuids: string[],
      callback: (success: boolean) => void,
    ) => {
      if (chatInstances.current[external_id]) {
        chatInstances.current[external_id].deleteMessages(uuids, callback);
      }
    },
    [],
  );

  const getChatMessages = useCallback(async (external_id: string) => {
    console.log('Get Chat Messages', {
      hasChatHistory: !!chatInstances.current[external_id]?.chatHistory,
    });
    if (chatInstances.current[external_id]?.isInitialized()) {
      await chatInstances.current[external_id].fetchMessageHistory();
      return !!chatInstances.current[external_id]?.has_more;
    }
  }, []);

  return React.createElement(ChatContext.Provider, {
    value: {
      subscribe,
      publish,
      refresh,
      refreshUser,
      subscribeChatEvents,
      removeUnfocusedInstances,
      deleteMessages,
      getChatMessages,
      setupAxios,
      updatePrimaryCandidateMap,
      setPrimaryCandidateOfTurn,
      reconnect: reconnectAppChatSocket,
      updateConfiguration,
    },
    children,
  });
};

export const useChatContext = () => {
  return useContext(ChatContext);
};

const buildChatInstance = (
  serviceType: ChatServiceType,
  external_id: string,
  user: Participant,
  onChatEventCallback: (eventType: ChatEventEnum, payload?: any) => void,
  history_external_id?: string,
  new_history?: boolean,
  fetchAllCandidates?: boolean,
): ChatInterface => {
  switch (serviceType) {
    case ChatServiceType.Legacy:
      return new ChatInstanceFetchAsync(
        serviceType,
        external_id,
        user,
        onChatEventCallback,
        history_external_id,
        new_history,
      );
    case ChatServiceType.Neo:
      return new ChatInstanceWebSocket(
        serviceType,
        external_id,
        user,
        onChatEventCallback,
        history_external_id,
        new_history,
        fetchAllCandidates,
      );
    case ChatServiceType.Room:
      return new RoomInstanceWebSocket(
        serviceType,
        external_id,
        user,
        onChatEventCallback,
        history_external_id,
        new_history,
      );
  }
};
