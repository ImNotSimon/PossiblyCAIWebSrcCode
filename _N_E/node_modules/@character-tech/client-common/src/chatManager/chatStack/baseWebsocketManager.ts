import { ErrorLogger } from '../../DebugLog';
import { getWebsocketTtlMs } from '../../lib/axiosConstants';
import { ChatEventEnum } from '../chatManagerTypes';
import { neoAPI } from '../neoAPI';

type AuthenticationState =
  | 'unauthenticated'
  | 'authenticating'
  | 'authenticated';

export class BaseWebsocketManager {
  onChatEventCallback: (eventType: ChatEventEnum, payload?: any) => void;
  ttlTimer = 0;
  authState: AuthenticationState = 'unauthenticated';

  constructor(
    _onChatEventCallback: (eventType: ChatEventEnum, payload?: any) => void,
  ) {
    this.onChatEventCallback = _onChatEventCallback;
    this.restartTTLTimer();
  }

  protected async authenticate() {
    if (this.authState === 'unauthenticated') {
      try {
        this.authState = 'authenticating';
        await neoAPI.ping();
        this.authState = 'authenticated';
      } catch (error) {
        ErrorLogger.logError('Failed to authenticate websocket', { error });
        this.authState = 'unauthenticated';
      }
    }
  }

  protected disconnectWebsocket() {}

  protected checkAuthentication({
    message,
    code,
  }: {
    message?: string;
    code?: number;
  }) {
    if (
      code === 403 ||
      code === 401 ||
      message?.includes('403') ||
      message?.includes('401') ||
      message?.toLowerCase().includes('unauthorized')
    ) {
      console.log(`websocket no longer authenticated`, { message, code });
      // retrigger auth on next connect
      this.authState = 'unauthenticated';
    }
  }

  protected restartTTLTimer() {
    clearTimeout(this.ttlTimer);
    const ttlMs = getWebsocketTtlMs();
    if (ttlMs > 0) {
      // @ts-ignore NEEDED to avoid breaking builds. Thinks setInterval returns NodeJS.Timer
      this.ttlTimer = setTimeout(() => {
        this.disconnectWebsocket();
      }, ttlMs);
    }
  }
}
